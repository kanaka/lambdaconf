<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Make Your Own Lisp Interpreter in 10 Incremental Steps</title>

    <meta name="description" content="Make Your Own Lisp Interpreter in 10 Incremental Steps">
    <meta name="author" content="Joel Martin">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section>
          <h1>Make-A-Lisp</h1>
          <h3>Make Your Own Lisp Interpreter in 10 Incremental Steps</h3>
          <p>LambdaConf 2016</p>
          <p><i>Press 's' to show speaker notes</i></p>
          <aside class="notes">
            <ul>
              <li>Silence phone
              <li>Preload <a href="https://github.com/kanaka/mal/blob/master/process/guide.md">guide</a>
              <li>Sharing/screen configuration: tmix with "edit" and "test" windows/buffers.
              <li>`git checkout start` in mal.workshop/
            </ul>
          </aside>
        </section>

        <section>
          <h2>About Me</h2>
          <p>Joel Martin (kanaka)</a></p>
          <p><a href="https://github.com/kanaka">github.com/kanaka</a></p>
          <p><a href="http://twitter.com/bus_kanaka">@bus_kanaka</a></p>
          <p class="fragment">Principal Software Engineer at ViaSat, Inc</p>
          <p class="fragment">Clojure</p>
          <p class="fragment">Satellites!</p>
          <p class="fragment">Creator of noVNC and websockify</p>
          <aside class="notes">
            <ul>
                <li>My name is Joel Martin
                <li><span class="next">&gt;&gt;</span>Principal Software Engineer at ViaSat, Inc
                <li>At ViaSat I get to build systems using <span
                class="next">&gt;&gt;</span> Clojure, work with some
                amazing people, and <span class="next">&gt;&gt;</span>
                work at a company that does broadband Internet from
                space.
                <li><span class="next">&gt;&gt;</span> If you've heard
                my name before, it's almost certainly for starting the
                noVNC and websockify projects.
            </ul>
          </aside>
        </section>

        <section>
          <h3>Front Matter</h3>
          <ul>
            <li>Goal: <font color="green">Learn Lisp by creating a Lisp Interpreter</font>
            <li>Prerequisites:
            <ul>
              <li>Moderate experience in any PL is recommended.
              <li>git clone <a href="https://github.com/kanaka/mal.workshop">https://github.com/kanaka/mal.workshop</a>
              <li>git, make and one of: ruby, node.js, or python
            </ul>
            <li>Resources:
            <ul>
                <li><a href="https://github.com/kanaka/mal/blob/master/process/guide.md">github.com/kanaka/mal/blob/master/process/<font color="green">guide</font>.md</a>
                <li><a href="http://kanaka.github.io/mal/process/cheatsheet.html">kanaka.github.io/mal/process/<font color="green">cheatsheet</font>.html</a>
                <li><a href="https://lambdaconf.slack.com">lambdaconf.slack.com</a>: <font color="green">#workshop_make_a_lisp</font>
                <li><font color="green">#mal</font> at irc.freenode.net:6667
            </ul>
          </ul>
          <aside class="notes">
            <ul>
                <li>Goal
                <ul>
                  <li>Creating a new compiler or interpreter for any
                  given language will make you an expert in that
                  language. The catch-22 is that for most languages you
                  need to already have deep expertise in compiler and/or
                  interpreter design in order to do that.
                  <li>Except for Lisp. Any moderately skilled developer
                  can implement a Lisp interpreter.
                  <li>So if you here to learn the Zen of Lisp by
                  implementing a Lisp then you're in the right place.
                </ul>
                <li>Prerequisites:
                <ul>
                  <li>Clone the workshop repo if you haven't already
                  <li>You can implement Mal in any Turing complete
                    language that has decent I/O capabilities. But for
                    this workshop, I'm going to show examples in Ruby,
                    JavaScript and Python.
                  <li>So I highly recommend that you pick one of those
                  for hands-on practice during this workshop and then
                  branch out from there.
                </ul>
                <li>Lots to cover and I'm going to move fast. If you
                get behind, there are tags in the workshop repo to
                help you catch up.
                <li>Guide: workshop content but more detailed.
                <li>Cheatsheet: good after you've been through once
                for reference
                <li>Slack channel. I'll be there after workshop during
                conference and for a week or two after to answer
                questions.
                <li>More permanent: #mal channel on freenode for
                general mal/make-a-lisp discussion.
            </ul>
          </aside>
        </section>

        <section>
          <h2>Agenda</h2>
          <ul style="font-size: 0.8em;">
            <li>Lisp Crash Course
            <li>Mal and the Make-A-Lisp Process
            <li>Step 0
            <li>Step 1 (Ruby)
            <li><font color="gray">--- 10 min break ---</font>
            <li>Step 2 (JavaScript)
            <li>Step 3 (Python)
            <li><font color="gray">--- 30 min break ---</font>
            <li>Step 4 (Ruby)
            <li>Step 5 (JavaScript)
            <li><font color="gray">--- 10 min break ---</font>
            <li>Step 6 (Python)
            <li>Step 6++ (Ruby)
            <li>Steps 7-A
            <li>Finishing Thoughts
          </ul>
          <aside class="notes">
            <ul>
                <li>Start with a quick Lisp crash course
                <li>Introduce mal
                <li>Then jump into the steps with three breaks
                <li>By step 6: you'll have a fully functioning Lisp
                <li>Steps 7-A: I'll discuss the Lisp concepts from
                these steps, but we won't have time for the hands-on
                implementation. But steps 1-6 give you the core
                foundation to build on and the make-a-lisp guide has
                implementation details for those steps.
            </ul>
          </aside>
        </section>

        <section>
          <section>
            <h2>Lisp Crash Course</h2>
            <pre class="fragment" style="font-size: 100px; text-align: center;"><code class="clojure" data-trim contenteditable>
          (+ 1 41)
            </code></pre>
            <aside class="notes">
              <ul>
                <li>Lisp begins and ends with the evaluator, so let's
                talk about that
              </ul>
            </aside>
          </section>

          <section>
            <pre><code class="clojure" data-trim contenteditable>user&gt; 42
<div class="fragment">42
            </code></pre>
            <pre class="fragment"><code class="clojure" data-trim contenteditable>user&gt; "forty two"
<div class="fragment">"forty two"
            </code></pre>
            <pre class="fragment"><code class="clojure" data-trim contenteditable>user&gt; +
<div class="fragment">#&lt;plus function&gt;
            </code></pre>
            <pre class="fragment"><code class="clojure" data-trim contenteditable>user&gt; abc
<div class="fragment">[not found]
            </code></pre>
            <aside class="notes">
              <ul>
                <li>numbers evaluate to themselves
                <li>so do strings
                <li>symbols are evaluated by looking up what they are
                bound to in the current lexical environment or an
                ancestor of the current lexical environment.
                <li>"+" is a symbol that is defined in the root
                lexical environment. It evaluates to a function that
                adds two numbers.
                <li>If no binding is found then an error is raised.
              </ul>
            </aside>
          </section>

          <section>
            <pre><code class="clojure" data-trim contenteditable>user&gt; [+ 20 22]
<div class="fragment">[#&lt;plus function&gt; 20 22]
            </code></pre>
            <pre class="fragment"><code class="clojure" data-trim contenteditable>user&gt; [* 2 [+ 1 20]]
<div class="fragment">[#&lt;mult function&gt; 2 [#&lt;plus function&gt; 1 20]]
            </code></pre>
            <pre class="fragment"><code class="clojure" data-trim contenteditable>user&gt; (+ 20 22)
<div class="fragment">42
            </code></pre>
            <pre class="fragment"><code class="clojure" data-trim contenteditable>user&gt; (* 2 (+ 1 20))
<div class="fragment">42
            </code></pre>
            <aside class="notes">
              <ul>
                <li>Vectors evaluate each of their elements.
                <li>Including vectors in vectors (recursion)
                <li>Lists in Lisp are special. What happens during
                evaluation depends on what's in the first
                position.
                <ul>
                  <li>When the first position evaluates to
                  a function, then the other elments of the list
                  are evaluated and the function is called with
                  those evaluated argument as arguments.
                  <li>Again, lists can be embedded within lists.
                </ul>
              </ul>
            </aside>
          </section>

          <section>
            <pre><code class="clojure" data-trim contenteditable>user&gt; (if true (prn 3) (prn 4))
<div class="fragment">3
nil
            </code></pre>
            <pre class="fragment"><code class="clojure" data-trim contenteditable>user&gt; (if false (prn 3) (prn 4))
<div class="fragment">4
nil
            </code></pre>
            <aside class="notes">
              <ul>
                <li>When the first position is a special form
                (language syntax), then the special form itself
                determines how and whether the other elements are
                evaluated.
                <li>Another way to think about it is that special
                forms are like functions that get called with the
                arguments before evaluation.
                <li>In the case of the "if" special form, the first
                argument is evaluated, but only the second or third
                argument is evaluated depending on the truthiness of
                the first argument
              </ul>
            </aside>
          </section>

          <section>
            <pre class="fragment"><code class="clojure" data-trim contenteditable>user&gt; (def! abc (+ 1 2))
<div class="fragment">3
user&gt; abc
3
            </code></pre>
            <pre class="fragment"><code class="clojure" data-trim contenteditable>user&gt; (fn* (a b) (* a b))
<div class="fragment">(fn* (a b) (* a b))
            </code></pre>
            <pre class="fragment"><code class="clojure" data-trim contenteditable>user&gt; ( (fn* (a b) (* a b)) 6 7 )
<div class="fragment">42
            </code></pre>
            <aside class="notes">
              <ul>
                <li>def! is another special form that makes a change
                to the current lexical environment. The second
                argument is evaluated and the result is bound to the
                unevaluated symbol that is the first argument.
                <li>Note that the first argument can't be evaluated
                because we need the symbol, not what it evaluates to.
                We would get an error in this case.
                <li>abc now evaluates to 3 in the current lexical
                environment.
                <li>fn* is another special form that returns a new
                function. It does not evaluate either the parameter
                list or the function body. They are just stored as
                part of the data type that represents the function.
                <li>The function special form and the numbers 6 and
                7 are evaluated. The resulting function is called
                which creates a new exical environment with a and
                b bound to 6 and 7 respectively. The function body is
                evaluated in that new environment.
                <li>That's our 10 min Lisp crash course. There are
                some other important special forms and data-types, but
                you now know the core of Lisp.
                <li>Should be at <span class="next">15</span> min mark
              </ul>
            </aside>
          </section>

        </section>

        <section>
          <h2>The Inspiration</h2>
          <ul>
              <li class="fragment" data-fragment-index="1">Gherkin<br>
              <li class="fragment" data-fragment-index="3">lispy</li>
              <span class="fragment fade-in" data-fragment-index="2">
                <span class="fragment fade-out" data-fragment-index="3">
                  <img src="media/mindblown.gif"></img>
                </span>
              </span>
          </ul>
          <aside class="notes">
            <ul>
              <li> <span class="next">&gt;&gt;</span> Way back in 2013, Alan Dipert presented this at Clojure/conj
              <li>A Lisp implemented in bash <span class="next">&gt;&gt;</span> [mindblown]
              <li>This was basically my reaction.
              <li>Raised the question for me: what other
              non-traditional language could a Lisp be implemented in?
              <li>Had particular language in mind. As far as I knew,
              no one had ever written a Lisp using it.  You'll see why
              in a moment.
              <li><span class="next">&gt;&gt;</span> Lispy: a small
              and simple Python implementation of a Lisp interpreter
              by Peter Norvig. I used that as a model.
            </ul>
          </aside>
        </section>

        <section>
          <section>
            <h2>Mal Beginnings</h2>
            <aside class="notes">
              A bit on how mal began
              <span class="next">vv</span>
            </aside>
          </section>

          <section>
            <h2>JS</h2>
            <pre><code class="hljs" data-trim contenteditable>
...
function read_form(reader) {
    var token = reader.peek();
    switch (token) {
    // reader macros/transforms
    case ';': return null; // Ignore comments
    case '\'': reader.next();
               return [types._symbol('quote'), read_form(reader)];
    case '`': reader.next();
              return [types._symbol('quasiquote'), read_form(reader)];
    case '~': reader.next();
              return [types._symbol('unquote'), read_form(reader)];
...
            </code></pre>
            <aside class="notes">
              First did an implementation in JS to make sure
              I understood the process well. I had not made a Lisp
              from scratch before.
            </aside>
          </section>
          <section>
            <h2 class="fragment" data-fragment-index="1">GNU Make</h2>
            <pre><code class="hljs" data-trim contenteditable>
...
define READ_FORM
$(and $(READER_DEBUG),$(info READ_FORM: $($(1))))
$(call READ_SPACES,$(1))
$(foreach ch,$(word 1,$($(1))),\
  $(if $(filter $(SEMI),$(ch)),\
    $(call DROP_UNTIL,$(1),$(_NL)),\
  $(if $(filter $(SQUOTE),$(ch)),\
    $(eval $(1) := $(wordlist 2,$(words $($(1))),$($(1))))\
    $(call _list,$(call _symbol,quote) $(strip $(call READ_FORM,$(1)))),\
  $(if $(filter $(QQUOTE),$(ch)),\
    $(eval $(1) := $(wordlist 2,$(words $($(1))),$($(1))))\
    $(call _list,$(call _symbol,quasiquote) $(strip $(call READ_FORM,$(1)))),\
  $(if $(filter $(UNQUOTE),$(ch)),\
...
            </code></pre>
            <p class="fragment" class="fragment" data-fragment-index="2">"<font color="green">Ma</font>ke <font color="green">L</font>isp"
            <aside class="notes">
              <ul>
                <li>Here is a sample of the code from the target
                language that I was inspired to write a Lisp in.
                Anybody willing to guess what language this example
                code is written in?
                <li><span class="next">&gt;&gt;</span> GNU Make. And
                yes, it's really does work and it's a full
                implementation.
                <li><span class="next">SWITCH</span>
                <li>Demo
                <pre style="background: #aaa;">
cd make
make -f ./mal.mk
user&gt; ( (fn* [a b] (* a b)) 7 8)
less mal.mk</pre>
                <li><span class="next">SWITCH</span> <span
                    class="next">&gt;&gt;</span> The name "Mal"
                original meant "MAke Lisp".
              </ul>
          </section>
          <section>
            <h2>Bash</h2>
            <pre><code class="bash" data-trim contenteditable>
...
READ_FORM () {
  local token=${__reader_tokens[${__reader_idx}]}
  case "${token}" in
    \')   __reader_idx=$(( __reader_idx + 1 ))
          _symbol quote; local q="${r}"
          READ_FORM; local f="${r}"
          _list "${q}" "${f}" ;;
    \`)   __reader_idx=$(( __reader_idx + 1 ))
          _symbol quasiquote; local q="${r}"
          READ_FORM; local f="${r}"
          _list "${q}" "${f}" ;;
...
            </code></pre>
            <aside class="notes">
              <ul>
                <li>But then I decided to implement mal in bash. Mal
                and bash have a fairly different architecture.
              </ul>
            </aside>
          </section>
          <section>
            <h2>C</h2>
            <pre><code class="c" data-trim contenteditable>
...
MalVal *read_form(Reader *reader) {
    char *token;
    MalVal *form = NULL, *tmp;
    token = reader_peek(reader);
    if (!token) { return NULL; }
    switch (token[0]) {
    case ';':
        abort("comments not yet implemented");
        break;
    case '\'':
        reader_next(reader);
        form = _listX(2, malval_new_symbol("quote"),
                         read_form(reader));
        break;
...
            </code></pre>
            <aside class="notes">
              <ul>
                <li>Then I did C.
              </ul>
            </aside>
          </section>
          <section>
            <h2>Python</h2>
            <pre><code class="python" data-trim contenteditable>
...
def read_form(reader):
    token = reader.peek()
    # reader macros/transforms
    if token[0] == ';':
        reader.next()
        return None
    elif token == '\'':
        reader.next()
        return _list(_symbol('quote'), read_form(reader))
    elif token == '`':
        reader.next()
        return _list(_symbol('quasiquote'), read_form(reader))
...
            </code></pre>
            <aside class="notes">
              <ul>
                <li>Then python
              </ul>
            </aside>
          </section>
          <section>
            <h2>Clojure</h2>
            <pre><code class="clojure" data-trim contenteditable>
...
;; Override some tools.reader reader macros so that we can do our own
;; metadata and quasiquote handling
(alter-var-root #'r/macros
  (fn [f]
    (fn [ch]
      (case ch
        \` (wrap 'quasiquote)
        \~ (fn [rdr comma]
             (if-let [ch (rt/peek-char rdr)]
               (if (identical? \@ ch)
                 ((wrap 'splice-unquote) (doto rdr rt/read-char) \@)
                 ((wrap 'unquote) rdr \~))))
...
            </code></pre>
            <aside class="notes">
              <ul>
                <li>Clojure.
                <li>Mal is definitely a Lisp that was inspired by
                Clojure syntax and functionality:
                data-structures that are immutable by default, rich
                types and type literals, etc.
                <li>So implementing mal using Clojure just seemed
                like the right thing to do.
              </ul>
            </aside>
          </section>

          <section>
            <h2>PHP</h2>
            <pre><code class="php" data-trim contenteditable>
...
function read_form($reader) {
    $token = $reader->peek();
    switch ($token) {
    case '\'': $reader->next();
               return _list(_symbol('quote'),
                               read_form($reader));
    case '`':  $reader->next();
               return _list(_symbol('quasiquote'),
                               read_form($reader));
    case '~':  $reader->next();
               return _list(_symbol('unquote'),
                               read_form($reader));
...
            </code></pre>
          </section>

          <section>
            <h2>Java</h2>
            <pre><code class="java" data-trim contenteditable>
...
    public static MalVal read_form(Reader rdr)
            throws MalContinue, ParseError {
        String token = rdr.peek();
        if (token == null) { throw new MalContinue(); }
        MalVal form;

        switch (token.charAt(0)) {
            case '\'': rdr.next();
                       return new MalList(new MalSymbol("quote"),
                                          read_form(rdr));
            case '`': rdr.next();
                      return new MalList(new MalSymbol("quasiquote"),
                                         read_form(rdr));
...
            </code></pre>
          </section>
        </section>

        <section>
          <h2>An Accidental Discovery</h2>
          <p class="fragment">"<font color="green">Ma</font>ke <font color="green">L</font>isp" became "<font color="green">M</font>ake-<font color="green">A</font>-<font color="green">L</font>isp"
          <aside class="notes">
            <ul>
              <li>At some point I began to realize that Mal had become
              a very useful personal learning tool. I was able to
              learn new languages more quickly and to a greater depth
              than any other process I had used before.
              <li><span class="next">&gt;&gt;</span> And so Make Lisp
              became Make-A-Lisp
            </ul>
          </aside>
        </section>

        <section>
          <section>
            <h2>Mal and More Mal</h2>
          </section>
          <section>
            <h2>PostScript</h2>
            <pre><code class="prolog" data-trim contenteditable>
...
% read_form: read the next form from string start at idx
/read_form { 3 dict begin
    read_spaces
    /idx exch def
    /str exch def

    idx str length ge { null str idx }{ %if EOF

    /ch str idx get def  % current character
    ch 39 eq { %if '\''
        /idx idx 1 add def
        str idx read_form
        3 -1 roll   /quote exch 2 _list   3 1 roll
...
            </code></pre>
          <aside class="notes">
            <p>And I kept going</p>
            <p>Yes, Postscript the typesetting language.</p>
          </aside>
          </section>

          <section>
            <h2>C#</h2>
            <pre><code class="csharp" data-trim contenteditable>
...
        public static MalVal read_form(Reader rdr) {
            string token = rdr.peek();
            if (token == null) { throw new MalContinue(); }
            MalVal form = null;

            switch (token) {
                case "'": rdr.next();
                    return new MalList(new MalSymbol("quote"),
                                       read_form(rdr));
                case "`": rdr.next();
                    return new MalList(new MalSymbol("quasiquote"),
                                       read_form(rdr));
...
            </code></pre>
          </section>

          <section>
            <h2>Ruby</h2>
            <pre><code class="ruby" data-trim contenteditable>
...
def read_form(rdr)
    return case rdr.peek
        when ";" then  nil
        when "'" then  rdr.next; List.new [:quote, read_form(rdr)]
        when "`" then  rdr.next; List.new [:quasiquote, read_form(rdr)]
        when "~" then  rdr.next; List.new [:unquote, read_form(rdr)]
        when "~@" then rdr.next; List.new [:"splice-unquote", read_form(rdr)]
        when "^" then  rdr.next; meta = read_form(rdr);
                       List.new [:"with-meta", read_form(rdr), meta]
...
            </code></pre>
          </section>

          <section>
            <h2>Perl</h2>
            <pre><code class="perl" data-trim contenteditable>
...
sub read_form {
    my($rdr) = @_;
    my $token = $rdr->peek();
    given ($token) {
        when("'") { $rdr->next(); List->new([Symbol->new('quote'),
                                             read_form($rdr)]) }
        when('`') { $rdr->next(); List->new([Symbol->new('quasiquote'),
                                             read_form($rdr)]) }
        when('~') { $rdr->next(); List->new([Symbol->new('unquote'),
                                             read_form($rdr)]) }
...
            </code></pre>
          </section>

          <section>
            <h2>Go</h2>
            <pre><code class="golang" data-trim contenteditable>
...
func read_form(rdr Reader) (MalType, error) {
        token := rdr.peek()
        if token == nil {
                return nil, errors.New("read_form underflow")
        }
        switch *token {
        case `'`:
                rdr.next()
                form, e := read_form(rdr)
                if e != nil {
                        return nil, e
                }
                return List{[]MalType{Symbol{"quote"}, form}, nil}, nil
...
            </code></pre>
          </section>

          <section>
            <h2>Rust</h2>
            <pre><code class="rust" data-trim contenteditable>
...
fn read_form(rdr : &mut Reader) -> MalRet {
    let otoken = rdr.peek();
    let stoken = otoken.unwrap();
    let token = &stoken[..];
    match token {
        "'" => {
            let _ = rdr.next();
            match read_form(rdr) {
                Ok(f) => Ok(list(vec![symbol("quote"), f])),
                Err(e) => Err(e),
            }
        },
...
            </code></pre>
            <aside class="notes">
              <p>More challenging then average, but it's a very
              interesting language</p>
            </aside>
          </section>

          <section>
            <h2>R</h2>
            <pre><code class="r" data-trim contenteditable>
...
read_form &lt;- function(rdr) {
    token &lt;- Reader.peek(rdr)
    if (token == "'") {
        . &lt;- Reader.next(rdr);
        new.list(new.symbol("quote"), read_form(rdr))
    } else if (token == "`") {
        . &lt;- Reader.next(rdr);
        new.list(new.symbol("quasiquote"), read_form(rdr))
    } else if (token == "~") {
        . &lt;- Reader.next(rdr);
        new.list(new.symbol("unquote"), read_form(rdr))
...
            </code></pre>
          </section>

          <section>
            <h2>CoffeeScript</h2>
            <pre><code class="coffeescript" data-trim contenteditable>
...
read_form = (rdr) ->
  token = rdr.peek()
  switch token
    when '\'' then [_symbol('quote'), read_form(rdr.skip())]
    when '`'  then [_symbol('quasiquote'), read_form(rdr.skip())]
    when '~'  then [_symbol('unquote'), read_form(rdr.skip())]
    when '~@' then [_symbol('splice-unquote'), read_form(rdr.skip())]
    when '^'
      meta = read_form(rdr.skip())
      [_symbol('with-meta'), read_form(rdr), meta]
    when '@' then [_symbol('deref'), read_form(rdr.skip())]
...
            </code></pre>
          </section>

          <section>
            <h2>VB.NET</h2>
            <pre><code class="vbnet" data-trim contenteditable>
...
        Shared Function read_form(rdr As Reader) As MalVal
            Dim token As String = rdr.peek()
            If token Is Nothing Then
                throw New MalContinue()
            End If
            Dim form As MalVal = Nothing

            Select token
            Case "'"
                rdr.get_next()
                return New MalList(New MalSymbol("quote"),
                                   read_form(rdr))
...
            </code></pre>
          </section>

          <section>
            <h2>Scala</h2>
            <pre><code class="scala" data-trim contenteditable>
...
  def read_form(rdr: Reader): Any = {
    return rdr.peek() match {
      case "'"  => { rdr.next; _list(Symbol("quote"), read_form(rdr)) }
      case "`"  => { rdr.next; _list(Symbol("quasiquote"), read_form(rdr)) }
      case "~"  => { rdr.next; _list(Symbol("unquote"), read_form(rdr)) }
      case "~@" => { rdr.next; _list(Symbol("splice-unquote"), read_form(rdr)) }
      case "^"  => { rdr.next; val meta = read_form(rdr);
                     _list(Symbol("with-meta"), read_form(rdr), meta) }
      case "@"  => { rdr.next; _list(Symbol("deref"), read_form(rdr)) }
...
            </code></pre>
          </section>

          <section>
            <h2>Haskell</h2>
            <pre><code class="haskell" data-trim contenteditable>
...
read_form :: Parser MalVal
read_form =  do
    ignored
    x &lt;- read_macro
     &lt;|> read_list
     &lt;|> read_vector
     &lt;|> read_hash_map
     &lt;|> read_atom
    return $ x

read_str :: String -> IOThrows MalVal
read_str str = case parse read_form "Mal" str of
...
            </code></pre>
          </section>

          <section>
            <h2>Racket</h2>
            <pre><code class="scheme" data-trim contenteditable>
...
(define (read_form rdr)
  (let ([token (send rdr peek)])
    (if (null? token)
      (raise (make-blank-exn "blank line" (current-continuation-marks)))
      (cond
        [(equal? "'" token) (send rdr next) (list 'quote (read_form rdr))]
        [(equal? "`" token) (send rdr next) (list 'quasiquote (read_form rdr))]
        [(equal? "~" token) (send rdr next) (list 'unquote (read_form rdr))]
        [(equal? "~@" token) (send rdr next) (list 'splice-unquote (read_form rdr))]
        [(equal? "^" token) (send rdr next)
                            (let ([meta (read_form rdr)])
                              (list 'with-meta (read_form rdr) meta))]
...
            </code></pre>
          </section>

          <section>
            <h2>Lua</h2>
            <pre><code class="lua" data-trim contenteditable>
...
function M.read_form(rdr)
    local token = rdr:peek()

    if "'" == token then
        rdr:next()
        return List:new({Symbol:new('quote'), M.read_form(rdr)})
    elseif '`' == token then
        rdr:next()
        return List:new({Symbol:new('quasiquote'), M.read_form(rdr)})
    elseif '~' == token then
        rdr:next()
        return List:new({Symbol:new('unquote'), M.read_form(rdr)})
...
            </code></pre>
          </section>

          <section>
            <h2><font color="green">OCaml</font></h2>
            <pre><code class="ocaml" data-trim contenteditable>
...
and read_form all_tokens =
  match all_tokens with
    | [] -> raise End_of_file;
    | token :: tokens ->
      match token with
        | "'"  -> read_quote "quote" tokens
        | "`"  -> read_quote "quasiquote" tokens
        | "~"  -> read_quote "unquote" tokens
        | "~@" -> read_quote "splice-unquote" tokens
        | "@"  -> read_quote "deref" tokens
...
            </code></pre>
            <aside class="notes">
              <ul>
                <li>OCaml was implementation #23
                <li>But there was a critical difference about the
                OCaml implementation: it was created by someone else.
                chouser (a friend and colleague who also wrote the
                book "The Joy of Clojure")
                <li>Marked a new era for mal (Jan 2015). The beginning
                of a step-by-step guide. Other people have created
                more implementations than I have since then.
                <li>Mal and make-a-lisp was no longer just my pet
                project.
                <li>Should be at <span class="next">~20</span> min mark
              </ul>
            </aside>
          </section>
        </section>

        <section data-background="#ffffff">
          <h4>Mal Today</h4>
          <img class="fragment" src="media/language_montage.png"
               width="100%" style="box-shadow: none;"></img>
          <aside class="notes">
            <ul>
              <li>Which bring us to today. <span class="next">&gt;&gt;</span>
              <li>There are now 53 implementations.
              <li>20 of the last 31 were created by others.
              <li>The past 12 months have averaged more than
              1.5 implementations per month.
            </ul>
          </aside>
        </section>

        <section data-background="#ffffff" data-transition="none">
          <h2>Let's Make a Lisp</h2>
          <ul class="fragment">
            <li>Hint, to catch up:<br>
              <pre>git checkout stepX_completed</pre>
            <ul>
              <ul>
                <li>where X is current step - 1
              </ul>
            </ul>
          </ul>
          <aside class="notes">
            <ul>
              <li>Enough talking, let's make a lisp
              <li><span class="next">&gt;&gt;</span>The workshop
              repository is tagged with the incremental steps. To
              catch up, checkout stepX_completed (X = current-1). You
              will need to move your in progress code out of the way
              first (add and stash).
            </ul>
          </aside>
        </section>

        <section data-background="#ffffff" data-transition="none">
          <h3>The Steps</h3>
          <aside class="notes">
            <ul>
              <li>Everybody ready?
            </ul>
          </aside>
        </section>

        <section data-background="#ffffff" data-transition="none">
          <section data-background="#ffffff" data-transition="none">
            <h4>Step 0 - Read/Eval/Print Loop</h4>
            <img src="media/step0_repl.png"
                 width="80%" style="box-shadow: none;"></img>
            <aside class="notes">
              aside/step0.html part 1
            </aside>
          </section>

          <section data-background="#ffffff" data-transition="none">
            <h4>Choose One:</h4>
            <table>
            <tr><td width=20%><font color="green">Ruby</font><br>
                                                  step0_repl.rb</td>
            <td><pre><code class="ruby" data-trim contenteditable>
require "readline"
while line = Readline.readline("user> ", true)
    puts line
end
            </code></pre></td>

            <tr><td width=20%><font color="green">JavaScript</font><br>
                                                  step0_repl.js</td>
            <td><pre><code class="javascript" data-trim contenteditable>
var rlSync = require('./readline').readlineSync
while ((line = rlSync('user> ')) !== null) {
    console.log(line)
}
            </code></pre></td>

            <tr><td width=20%><font color="green">Python 3</font><br>
                                                step0_repl.py</td>
            <td><pre><code class="python" data-trim contenteditable>
import readline
while True:
    try: print(input("user> "))
    except EOFError: break
            </code></pre></td>

            </table>
            <aside class="notes">
              aside/step0.html part 2
            </aside>
          </section>

          <section data-background="#ffffff" data-transition="none">
            <h4>Step 0 Hands On</h4>
            <ul>
              <li>Verify you can run Step 0 in your target language:<br>
                  <pre><code class=bash>ruby ruby/step0_repl.rb</code></pre>
                  <pre><code class=bash>node js/step0_repl.js</code></pre>
                  <pre><code class=bash>python3 python/step0_repl.py</code></pre>
              <li>Get Step 0 tests to run in your target language:<br>
                  <pre><code class=bash>make OPTIONAL=0 test^ruby^step0</code></pre>
                  <pre><code class=bash>make OPTIONAL=0 test^js^step0</code></pre>
                  <pre><code class=bash>make OPTIONAL=0 test^python^step0</code></pre>
            </ul>
          </section>

        </section>

        <section data-background="#ffffff" data-transition="none">
          <section data-background="#ffffff" data-transition="none">
            <h4>Step 1 - Reader & Printer</h4>
            <img src="media/step1_read_print.png"
                 width="80%" style="box-shadow: none;"></img>
            <aside class="notes">
              aside/step1.html part 1
            </aside>
          </section>

          <section data-background="#ffffff" data-transition="none">
            <h3>The Reader</h3>
            <img src="media/reader.png"
                 width="80%" style="box-shadow: none;"></img>
            <aside class="notes">
              aside/step1.html part 2
            </aside>
          </section>

          <section data-background="#ffffff" data-transition="none">
            <h4>Step 1 Hands On</h4>
            <ul>
              <li>Finish implementing read_list() in reader.EXT
              <li>Get all Step 1 tests to pass:<br>
                  <pre>make OPTIONAL=0 test^<font color="green">IMPL</font>^step1</pre>
            </ul>
            <aside class="notes">
              aside/step1.html part 3
            </aside>
          </section>

        </section>

        <section data-background="#ffffff" data-transition="none">
          <section data-background="#ffffff" data-transition="none">
            <h4>Step 2 - Expression Evaluation</h4>
            <img src="media/step2_eval.png"
                 width="80%" style="box-shadow: none;"></img>
            <aside class="notes">
              aside/step2.html part 1
            </aside>
          </section>

          <section data-background="#ffffff" data-transition="none">
            <h4>Step 2 Hands On</h4>
            <ul>
              <li>Implement eval_ast(ast,env) to handle:
                <ul>
                  <li>symbol: lookup in environemnt
                  <li>list: evaluate each element returning new list
                  <li>otherwise return ast
                </ul>
              <li>Implement EVAL(ast, env):
                <ul>
                  <li>if ast is not list: return eval_ast
                  <li>otherwise, eval_ast and apply/invoke function
                </ul>
              <li>Get all Step 2 tests to pass:<br>
                  <pre>make OPTIONAL=0 test^<font color="green">IMPL</font>^step2</pre>
            </ul>
            <aside class="notes">
              aside/step2.html part 2
            </aside>
          </section>
        </section>

        <section data-background="#ffffff" data-transition="none">
          <section data-background="#ffffff" data-transition="none">
            <h4>Step 3 - Lexical Environments</h4>
            <img src="media/step3_env.png"
                 width="80%" style="box-shadow: none;"></img>
            <aside class="notes">
              aside/step3.html part 1
            </aside>
          </section>

          <section data-background="#ffffff" data-transition="none">
            <h4>Step 3 Hands On (part 1)</h4>
            <ul>
              <li>Implement Env class/object and methods:
                <ul>
                  <li>set()
                  <li>find()
                  <li>get()
                </ul>
              <li>Use Env to define repl_env step3_env.EXT
            </ul>
            <aside class="notes">
              aside/step3.html part 2
            </aside>
          </section>

          <section data-background="#ffffff" data-transition="none">
            <h4>Step 3 Hands On (part 2)</h4>
            <ul>
              <li>Implement def! special form
              <li>Implement let* special form
              <li>Get all Step 3 tests to pass:<br>
                  <pre>make OPTIONAL=0 test^<font color="green">IMPL</font>^step3</pre>
            </ul>
            <aside class="notes">
              aside/step3.html part 3
            </aside>
          </section>
        </section>

        <section data-background="#ffffff" data-transition="none">
          <section data-background="#ffffff" data-transition="none">
            <h4>Step 4 - Conditionals, Closures & Side-Effects</h4>
            <img src="media/step4_if_fn_do.png"
                 width="80%" style="box-shadow: none;"></img>
            <aside class="notes">
              aside/step4.html part 1
            </aside>
          </section>

          <section data-background="#ffffff" data-transition="none">
            <h4>Step 4 Hands On (part 1)</h4>
            <ul>
              <li>Implement special forms:
                <ul>
                  <li>do
                  <li>if
                </ul>
              <li>Get Step 4 do/if tests to pass:<br>
                  <pre>make OPTIONAL=0 test^<font color="green">IMPL</font>^step4</pre>
            </ul>
            <aside class="notes">
              aside/step4.html part 2
            </aside>
          </section>

          <section data-background="#ffffff" data-transition="none">
            <h4>Functions</h4>
            <ul>
              <li>Define / Create: <pre style="font-size: 40px; text-align: left;"><code class="clojure" data-trim contenteditable>
          (fn* (a b) (* a b))
            </code></pre>
              <ul style="font-size: 25px">
                <li>Capture/store:
                <ul>
                  <li>Current (defining) environment
                  <li>Parameter list: (a b)
                  <li>Function body: (* a b)
                </ul>
              </ul>
              <br>
              <li>Call / Invoke / Apply:
            <pre style="font-size: 40px; text-align: left;"><code class="clojure" data-trim contenteditable>
          (  (fn* (a b) (* a b))   7 8 )      ;
            </code></pre>
              <ul style="font-size: 25px">
                <li>New environment using captured environment as outer/parent
                <ul>
                    <li>with parameter symbols bound to calling arguments
                </ul>
              </ul>
            </ul>
            <aside class="notes">
            </aside>
          </section>

          <section data-background="#ffffff" data-transition="none">
            <h4>Step 4 Hands On (part 2)</h4>
            <ul>
              <li>Implement Env constructor with bindings
              <li>Implement fn* special form (return a closure)
              <li>Get all Step 4 tests to pass:<br>
                  <pre>make OPTIONAL=0 test^<font color="green">IMPL</font>^step4</pre>
            </ul>
            <aside class="notes">
              aside/step4.html part 3
            </aside>
          </section>
        </section>

        <section data-background="#ffffff" data-transition="none">
          <section data-background="#ffffff" data-transition="none">
            <h4>Step 5 - Tail-Call Optimization</h4>
            <img src="media/step5_tco.png"
                 width="80%" style="box-shadow: none;"></img>
            <aside class="notes">
              aside/step5.html part 1
            </aside>
          </section>

          <section data-background="#ffffff" data-transition="none">
            <h4>Step 5 Hands On</h4>
            <ul>
              <li>Implement TCO loop for:
                <ul>
                  <li>let*
                  <li>do
                  <li>if
                </ul>
              <li>Capture env, ast, and params in fn* special form
              <li>Implement TCO loop in EVAL apply section
              <li>Get all Step 5 tests to pass:<br>
                  <pre>make OPTIONAL=0 test^<font color="green">IMPL</font>^step5</pre>
            </ul>
            <aside class="notes">
              aside/step5.html part 2
            </aside>
          </section>

        </section>

        <section data-background="#ffffff" data-transition="none">
          <section data-background="#ffffff" data-transition="none">
            <h4>Step 6 - Files, Atoms, Arguments & Eval</h4>
            <img src="media/step6_file.png"
                 width="80%" style="box-shadow: none;"></img>
            <aside class="notes">
              aside/step6.html part 1
            </aside>
          </section>

          <section data-background="#ffffff" data-transition="none">
            <h4>Step 6 Hands On</h4>
            <ul>
              <li>Add *ARGV*
              <li>Implement eval
              <li>Implement load-file
              <li>Implement script mode
              <li>Get all Step 6 tests to pass:<br>
                  <pre>make OPTIONAL=0 test^<font color="green">IMPL</font>^step6</pre>
              <li>Python hint:<pre><code class="python" data-trim contenteditable>
...                                                                               
elif "fn*" == a0:
    f = types.Function(ast[2], ast[1], env)
    f.apply = lambda args: EVAL(f.ast, Env(f.env, f.params, list(args)))
    return f
</code></pre>
            </ul>
            <aside class="notes">
              aside/step6.html part 2
            </aside>
          </section>

          <section data-background="#ffffff" data-transition="none">
            <h4>Step 6++ - (a touch of Step A)</h4>
            <aside class="notes">
              aside/step6++.html part 1
            </aside>
          </section>

          <section data-background="#ffffff" data-transition="none">
            <h4>Self-Hosting</h4>
            <img src="media/inception_top.jpg"
                 style="border: 0px; box-shadow: 0 0 1em;"></img>
            <aside class="notes">
              aside/step6++.html part 1
            </aside>
          </section>

          <section data-background="#ffffff" data-transition="none">
            <h4>Step 6++ Hands On</h4>
            <ul>
              <li>Add *host-language*
              <li>Add REPL startup header printing
              <li>Implement new readline core function
              <ul>
                <li>readline
              </ul>
              <li>Test self-hosting of ../mal6/step1_read_print.mal
              <li>Implement new core functions:
              <ul>
                <li>throw
                <li>symbol?
                <li>readline
                <li>apply
              </ul>
              <li>Test self-hosting of ../mal6/step{2-6}*.mal
            </ul>
            <aside class="notes">
              aside/step6++.html part 2
            </aside>
          </section>

        </section>

        <section data-background="#ffffff" data-transition="none">
          <h4>Step 7 - Quote & Quasiquote</h4>
          <img src="media/step7_quote.png"
               width="80%" style="box-shadow: none;"></img>
          <aside class="notes">
            <ul>
              <li>Should be at <span class="next">5:15pm</span> mark
              <li>A Touch of Meta-Programming
              <li>Power of Lisp is the ability to treat code as data
              <li>Show examples (in full mal):
              <ul>
                  <li>quote: <pre>(quote (7 8))</pre>
                  <li>quasiquote: <pre>(def! x 7)
(def! y (list 7 8))
(quasiquote (6 7 8))
(quasiquote (6 (unquote x) 8))
(quasiquote (6 (splice-unquote y) 9))
</pre>
            </ul>
          </aside>
        </section>

        <section data-background="#ffffff" data-transition="none">
          <h4>Step 8 - Macros</h4>
          <img src="media/step8_macros.png"
               width="80%" style="box-shadow: none;"></img>
          <aside class="notes">
            <ul>
              <li>Meta-Programming Realized
              <li>Ability to generate Lisp code on the fly
              <li>Another way of looking at it is that macros are
              a way of defining new special form in mal itself.
              <li>Sad couldn't get to this in the workshop, however,
              I highly encourage you to continue on and implement
              macro support because it will definitely give you an
              enlightenment moment.
              <li>I personally found that implementing macros was the
              moment when I actually began to understand them.
              <li>Example:<pre>
(defmacro! unless (fn* (pred a b) (quasiquote (if (unquote pred) (unquote b) (unquote a)))))
(unless true (prn 7) (prn 8))
(unless false (prn 7) (prn 8))
(macroexpand (unless false (prn 7) (prn 8)))
</pre>
            </ul>
          </aside>
        </section>

        <section data-background="#ffffff" data-transition="none">
          <h4>Step 9 - Exception Handling</h4>
          <img src="media/step9_try.png"
               width="80%" style="box-shadow: none;"></img>
          <aside class="notes">
            <ul>
              <li>Try and Try Again
              <li>Uses language's native exception handling if
              available.
              <li>Try to evaluate the try* body, if there is an
              exception, then bind it in a new environment and
              evaluate the catch* body in that new environment.
              <li>Example:<pre>
(try* (abc 1 2 3) (catch* exc (do (prn "Ignoring exception" exc "and returning 7") 7)))
</pre>
              <li>Miscellaneous core functions.
              <li>Good place to implement other types if you have
              deferred them until now.
            </ul>
          </aside>
        </section>

        <section data-background="#ffffff" data-transition="none">
          <section data-background="#ffffff" data-transition="none">
            <h4>Step A - Mal</h4>
            <img src="media/stepA_mal.png"
                 width="80%" style="box-shadow: none;"></img>
            <aside class="notes">
              <ul>
                <li>Result: Mal in Mal
                <li>The miscellaneous things needed for full self-hosting.
                <li>We already implemented some of these to self-host
                the mal6 implementation at least up through step 6.
                <li>However, mal6 is an ugly implementation of mal for
                this workshop called mal6. The real implementation of
                mal-in-mal is much more similar to a normal
                implementation of mal (without lots of workarounds) and
                is itself implemented all the way through stepA. It uses
                vectors, hash-maps, macros, metadata and exceptions
                support from step7-A.
                <li>Example:<pre>
  cd mal/c   # full mal implementation in C
  ./stepA_mal ../mal/stepA_mal.mal
  ./stepA_mal ../mal/stepA_mal.mal ../mal/stepA_mal.mal
  </pre>
                <li>C implementation of mal running the mal
  implementation of mal which is running the mal implementation of
  mal.
                <li><span class="next">vv</span>
              </ul>
            </aside>
          </section>

          <section data-background="#ffffff" data-transition="none">
            <img src="media/inception_top.jpg"
                 style="border: 0px; box-shadow: 0 0 1em;"></img>
            <aside class="notes">
              <ul>
                <li>Feeling like this again?
                <li>Could go further, but it gets exponentially slower,
                so it takes a while
                <li>Step A is also where interop with the host is
                implemented but that's entirely optional.
              </ul>
            </aside>
          </section>

        </section>

        <section>
          <h4>Questions?</h4>
          <div class="fragment">
          <hr>
          <h4>Links</h4>
          <ul>
            <li><a href="https://github.com/kanaka/mal">github.com/kanaka/mal</a>
            <li><a href="https://github.com/kanaka/mal.workshop">github.com/kanaka/mal.workshop</a>
            <li><a href="https://github.com/kanaka/lambdaconf">github.com/kanaka/lambdaconf</a>
            <li><a href="https://github.com/kanaka/mal/blob/master/process/guide.md">github.com/kanaka/mal/blob/master/process/<font color="green">guide</font>.md</a>
            <li><span style="color: green">#workshop_make_a_lisp</span> (lambdaconf.slack.com)
            <li><span style="color: green">#mal</span> (irc.freenode.net)
            <li><a href="http://twitter.com/bus_kanaka">@bus_kanaka</a>
            <li><a href="http://viasat.com">viasat.com</a>
          </ul>
          </div>
          <aside class="notes">
            <ul>
              <li>Should be at <span class="next">5:25pm</span> mark
              <li>That brings us to the end of this workshop. So I'll
              take any final questions.
              <li><span class="next">&gt;&gt;</span>I'll also put up
              some reference links while I take questions.
              <li>While end of workshop, this shouldn't be the end for
              this little journey.
              <li>I strongly encourage you to finish your
              implementation (refer to the guide for more detail).
              <li>Then continue with one of these options:
              <ul>
                <li>Pick a harder language that you know to do an
                implementation in (solidify you understanding of
                Lisp).
                <li>Implement it in a language you don't know to learn
                that language.
                <li>Implement it in a language that mal hasn't been
                done in yet and submit it for inclusion in the main
                mal tree.
              </ul>
              <li>As I mentioned, I will try to periodical check the
              mal slack channel during the rest of the conference and
              for a couple weeks after.
              <li>Also, join the #mal IRC channel on freenode for
              ongoing general mal discussion.
              <li>Thanks!
            </ul>
          </aside>
        </section>

        <section>
          <h2>Extra Material</h2>
        </section>

        <section data-background="#ffffff">
          <img src="media/language_graph.png"
               width="70%" style="box-shadow: none;"></img>
        </section>

        <section>
          <h2>New Implementation Ideas</h2>
          <font size=5em>
          <span style="padding: 50px">
          <ul>
            <li>Something old
            <ul>
              <li>Fortran
              <li>COBOL
              <li>Assembly
            </ul>
          </ul>
          </span>
          <span style="padding: 50px">
          <ul>
            <li>Something new
            <ul>
              <li>Idris
              <li>Elm
              <li>TypeScript
            </ul>
          </ul>
          </span>

          <br><br>

          <span style="padding: 50px">
          <ul>
            <li>Something borrowed<br>(from another domain)
            <ul>
              <li>TeX
              <li>Prolog
              <li>nginScript
            </ul>
          </ul>
          </span>
          <span style="padding: 50px">
          <ul>
            <li>Something blue<br>(corporate/government)
            <ul>
              <li>PowerShell
              <li>ColdFusion
              <li>MUMPS (OpenM)
            </ul>
          </ul>
          </font>
          </span>
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });

    </script>

  </body>
</html>
