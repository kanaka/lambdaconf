<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Make Your Own Lisp Interpreter in 10 Incremental Steps</title>

    <meta name="description" content="Make Your Own Lisp Interpreter in 10 Incremental Steps">
    <meta name="author" content="Joel Martin">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section>
          <h1>Make-A-Lisp</h1>
          <h3>Make Your Own Lisp Interpreter in 10 Incremental Steps</h3>
          <p>LambdaConf 2016</p>
          <p><i>Press 's' to show speaker notes</i></p>
          <aside class="notes">
            <ul>
              <li>Silence phone
              <li>Preload <a href="https://github.com/kanaka/mal/blob/master/process/guide.md">guide</a>
              <li>Sharing/screen configuration: tmix with "edit" and
              "test" windows/buffers.
              <li>`git checkout start` in mal.tutorial/
            </ul>
          </aside>
        </section>

        <section>
          <h2>About Me</h2>
          <p>Joel Martin (kanaka)</a></p>
          <p><a href="https://github.com/kanaka">github.com/kanaka</a></p>
          <p><a href="http://twitter.com/bus_kanaka">@bus_kanaka</a></p>
          <p class="fragment">Principal Software Engineer at ViaSat, Inc</p>
          <p class="fragment">Clojure</p>
          <p class="fragment">Satellites!</p>
          <p class="fragment">Creator of noVNC and websockify</p>
          <aside class="notes">
            <ul>
                <li>My name is Joel Martin
                <li>Principal Software Engineer at ViaSat, Inc
                <li>At ViaSat I get to build systems using <span
                class="next">&gt;&gt;</span> Clojure, work with some
                amazing people, and <span class="next">&gt;&gt;</span>
                work at a company that does broadband Internet from
                space.
                <li><span class="next">&gt;&gt;</span> If you've heard
                my name before, it's almost certainly for starting the
                noVNC and websockify projects.
                <li>Thanks to LambdaConf organizers for a great
                conference so far!
            </ul>
          </aside>
        </section>

        <section>
          <h3>Front Matter</h3>
          <ul>
            <li>Goal: <font color="green">Learn Lisp by creating a Lisp Interpreter</font>
            <li>Prerequisites:
            <ul>
              <li>Moderate experience in any PL is recommended.
              <li>git clone <a href="https://github.com/kanaka/mal.tutorial">github.com/kanaka/mal.tutorial</a>
              <li>git, make and one of: ruby, node.js, or python
            </ul>
            <li>Resources:
            <ul>
                <li><a href="https://github.com/kanaka/mal/blob/master/process/guide.md">github.com/kanaka/mal/blob/master/process/<font color="green">guide</font>.md</a>
                <li><a href="http://kanaka.github.io/mal/process/cheatsheet.html">kanaka.github.io/mal/process/<font color="green">cheatsheet</font>.html</a>
                <li><a href="https://lambdaconf.slack.com">lambdaconf.slack.com</a>: <font color="green">#workshop_make_a_lisp</font>
                <li><font color="green">#mal</font> at irc.freenode.net:6667
            </ul>
          </ul>
          <aside class="notes">
            <ul>
                <li>Goal
                <ul>
                  <li>Creating a new compiler or interpreter for any
                  given language will make you an expert in that
                  language. The catch-22 is that for most languages you
                  need to already have deep expertise in compiler and/or
                  interpreter design in order to do that.
                  <li>Except for Lisp. Any moderately skilled developer
                  can implement a Lisp interpreter.
                  <li>So if you here to learn the Zen of Lisp by
                  implementing a Lisp then you're in the right place.
                </ul>
                <li>Prerequisites:
                <ul>
                  <li>Clone the tutorial if you haven't already
                  <li>You can implement Mal in any Turing complete
                    language that has decent I/O capabilities. But for
                    this workshop, I'm going to show examples in Ruby,
                    JavaScript and Python.
                  <li>So I highly recommend that you pick one of those
                  for hands-on practice during this workshop and then
                  branch out from there.
                </ul>
                <li>Lots to cover and I'm going to move fast. If you
                get behind, there are tags in the tutorial repo to
                help you catch up.
                <li>Guide and cheatsheet
                <li>Slack channel. I'll be there after workshop during
                conference and for a week or two after to answer
                questions.
                <li>More permanent: #mal channel on freenode for
                general mal/make-a-lisp discussion.
            </ul>
          </aside>
        </section>

        <section>
          <h2>Agenda</h2>
          <ul style="font-size: 0.8em;">
            <li>Lisp Crash Course
            <li>Mal and the Make-A-Lisp Process
            <li>Step 0
            <li>Step 1 (Ruby)
            <li><font color="gray">--- 10 min break ---</font>
            <li>Step 2 (JavaScript)
            <li>Step 3 (Python)
            <li><font color="gray">--- 30 min break ---</font>
            <li>Step 4 (Ruby)
            <li>Step 5 (JavaScript)
            <li><font color="gray">--- 10 min break ---</font>
            <li>Step 6 (Python)
            <li>Step 6++ (Ruby)
            <li>Steps 7-A
            <li>Finishing Thoughts
          </ul>
          <aside class="notes">
            <ul>
                <li>Start with a quick Lisp crash course
                <li>Introduce mal
                <li>Then jump into the steps with three breaks
                <li>By step 6: you'll have a fully functioning Lisp
                <li>Steps 7-A: I'll discuss the Lisp concepts from
                these steps, but we won't have time for the hands-on
                implementation. But steps 1-6 give you the core
                foundation to build on and the make-a-lisp guide has
                implementation details for those steps.
            </ul>
          </aside>
        </section>

        <section>
          <section>
            <h2>Lisp Crash Course</h2>
            <pre class="fragment" style="font-size: 100px; text-align: center;"><code class="clojure" data-trim contenteditable>
          (+ 1 41)
            </code></pre>
            <aside class="notes">
              <ul>
                <li>Lisp begins and ends with the evaluator, so let's
                talk about that
              </ul>
            </aside>
          </section>

          <section>
            <pre><code class="clojure" data-trim contenteditable>user&gt; 42
<div class="fragment">42
            </code></pre>
            <pre class="fragment"><code class="clojure" data-trim contenteditable>user&gt; "forty two"
<div class="fragment">"forty two"
            </code></pre>
            <pre class="fragment"><code class="clojure" data-trim contenteditable>user&gt; +
<div class="fragment">#&lt;plus function&gt;
            </code></pre>
            <pre class="fragment"><code class="clojure" data-trim contenteditable>user&gt; abc
<div class="fragment">[not found]
            </code></pre>
            <aside class="notes">
              <ul>
                <li>numbers evaluate to themselves
                <li>so do strings
                <li>symbols are evaluated by looking up what they are
                bound to in the current lexical environment or an
                ancestor of the current lexical environment.
                <li>"+" is a symbol that is defined in the root
                lexical environment. It evaluates to a function that
                adds two numbers.
                <li>If no binding is found then an error is raised.
              </ul>
            </aside>
          </section>

          <section>
            <pre><code class="clojure" data-trim contenteditable>user&gt; [+ 20 22]
<div class="fragment">[#&lt;plus function&gt; 20 22]
            </code></pre>
            <pre class="fragment"><code class="clojure" data-trim contenteditable>user&gt; [* 2 [+ 1 20]]
<div class="fragment">[#&lt;mult function&gt; 2 [#&lt;plus function&gt; 1 20]]
            </code></pre>
            <pre class="fragment"><code class="clojure" data-trim contenteditable>user&gt; (+ 20 22)
<div class="fragment">42
            </code></pre>
            <pre class="fragment"><code class="clojure" data-trim contenteditable>user&gt; (* 2 (+ 1 20))
<div class="fragment">42
            </code></pre>
            <aside class="notes">
              <ul>
                <li>Vectors evaluate each of their elements.
                <li>Including vectors in vectors (recursion)
                <li>Lists in Lisp are special. What happens during
                evaluation depends on what's in the first
                position.
                <ul>
                  <li>When the first position evaluates to
                  a function, then the other elments of the list
                  are evaluated and the function is called with
                  those evaluated argument as arguments.
                  <li>Again, lists can be embedded within lists.
                </ul>
              </ul>
            </aside>
          </section>

          <section>
            <pre><code class="clojure" data-trim contenteditable>user&gt; (if true (prn 3) (prn 4))
<div class="fragment">3
nil
            </code></pre>
            <pre class="fragment"><code class="clojure" data-trim contenteditable>user&gt; (if false (prn 3) (prn 4))
<div class="fragment">4
nil
            </code></pre>
            <aside class="notes">
              <ul>
                <li>When the first position is a special form
                (language syntax), then the special form itself
                determines how and whether the other elements are
                evaluated.
                <li>Another way to think about it is that special
                forms are like functions that get called with the
                arguments before evaluation.
                <li>In the case of the "if" special form, the first
                argument is evaluated, but only the second or third
                argument is evaluated depending on the truthiness of
                the first argument
              </ul>
            </aside>
          </section>

          <section>
            <pre class="fragment"><code class="clojure" data-trim contenteditable>user&gt; (def! abc (+ 1 2))
<div class="fragment">3
user&gt; abc
3
            </code></pre>
            <pre class="fragment"><code class="clojure" data-trim contenteditable>user&gt; (fn* (a b) (* a b))
<div class="fragment">(fn* (a b) (* a b))
            </code></pre>
            <pre class="fragment"><code class="clojure" data-trim contenteditable>user&gt; ( (fn* (a b) (* a b)) 6 7 )
<div class="fragment">42
            </code></pre>
            <aside class="notes">
              <ul>
                <li>def! is another special form that makes a change
                to the current lexical environment. The second
                argument is evaluated and the result is bound to the
                unevaluated symbol that is the first argument.
                <li>Note that the first argument can't be evaluated
                because we need the symbol, not what it evaluates to.
                We would get an error in this case.
                <li>abc now evaluates to 3 in the current lexical
                environment.
                <li>fn* is another special form that returns a new
                function. It does not evaluate either the parameter
                list or the function body. They are just stored as
                part of the data type that represents the function.
                <li>The function special form and the numbers 6 and
                7 are evaluated. The resulting function is called
                which creates a new exical environment with a and
                b bound to 6 and 7 respectively. The function body is
                evaluated in that new environment.
                <li>That's our 10 min Lisp crash course. There are
                some other important special forms and data-types, but
                you now know the core of Lisp.
              </ul>
            </aside>
          </section>

        </section>

        <section>
          <h2>The Inspiration</h2>
          <ul>
              <li class="fragment" data-fragment-index="1">Gherkin<br>
              <li class="fragment" data-fragment-index="3">lispy</li>
              <span class="fragment fade-in" data-fragment-index="2">
                <span class="fragment fade-out" data-fragment-index="3">
                  <img src="media/mindblown.gif"></img>
                </span>
              </span>
          </ul>
          <aside class="notes">
            <ul>
              <li> <span class="next">&gt;&gt;</span> Way back in 2013, Alan Dipert presented this at Clojure/conj
              <li>A Lisp implemented in bash <span class="next">&gt;&gt;</span> [mindblown]
              <li>This was basically my reaction.
              <li>Raised the question for me: what other
              non-traditional language could a Lisp be implemented in?
              <li>Had particular language in mind. As far as I knew,
              no one had ever written a Lisp using it.  You'll see why
              in a moment.
              <li><span class="next">&gt;&gt;</span> Lispy: a small
              and simple Python implementation of a Lisp interpreter
              by Peter Norvig. I used that as a model.
            </ul>
          </aside>
        </section>

        <section>
          <section>
            <h2>Mal Beginnings</h2>
            <aside class="notes">
              A bit on how mal began
              <span class="next">vv</span>
            </aside>
          </section>

          <section>
            <h2>JS</h2>
            <pre><code class="hljs" data-trim contenteditable>
...
function read_form(reader) {
    var token = reader.peek();
    switch (token) {
    // reader macros/transforms
    case ';': return null; // Ignore comments
    case '\'': reader.next();
               return [types._symbol('quote'), read_form(reader)];
    case '`': reader.next();
              return [types._symbol('quasiquote'), read_form(reader)];
    case '~': reader.next();
              return [types._symbol('unquote'), read_form(reader)];
...
            </code></pre>
            <aside class="notes">
              First did an implementation in JS to make sure
              I understood the process well. I had not made a Lisp
              from scratch before.
            </aside>
          </section>
          <section>
            <h2 class="fragment" data-fragment-index="1">GNU Make</h2>
            <pre><code class="hljs" data-trim contenteditable>
...
define READ_FORM
$(and $(READER_DEBUG),$(info READ_FORM: $($(1))))
$(call READ_SPACES,$(1))
$(foreach ch,$(word 1,$($(1))),\
  $(if $(filter $(SEMI),$(ch)),\
    $(call DROP_UNTIL,$(1),$(_NL)),\
  $(if $(filter $(SQUOTE),$(ch)),\
    $(eval $(1) := $(wordlist 2,$(words $($(1))),$($(1))))\
    $(call _list,$(call _symbol,quote) $(strip $(call READ_FORM,$(1)))),\
  $(if $(filter $(QQUOTE),$(ch)),\
    $(eval $(1) := $(wordlist 2,$(words $($(1))),$($(1))))\
    $(call _list,$(call _symbol,quasiquote) $(strip $(call READ_FORM,$(1)))),\
  $(if $(filter $(UNQUOTE),$(ch)),\
...
            </code></pre>
            <p class="fragment" class="fragment" data-fragment-index="2">"<font color="green">Ma</font>ke <font color="green">L</font>isp"
            <aside class="notes">
              <ul>
                <li>Here is a sample of the code from the target
                language that I was inspired to write a Lisp in.
                Anybody willing to guess what language this example
                code is written in?
                <li><span class="next">&gt;&gt;</span> GNU Make. And
                yes, it's really does work and it's a full
                implementation.
                <li><span class="next">SWITCH</span>
                <li>Demo
                <pre style="background: #aaa;">
cd make
make -f ./mal.mk
user&gt; ( (fn* [a b] (* a b)) 7 8)
less mal.mk</pre>
                <li><span class="next">SWITCH</span> <span
                    class="next">&gt;&gt;</span> The name "Mal"
                original meant "MAke Lisp".
                <li>Should be at <span class="next">10</span> min mark
              </ul>
          </section>
          <section>
            <h2>Bash</h2>
            <pre><code class="bash" data-trim contenteditable>
...
READ_FORM () {
  local token=${__reader_tokens[${__reader_idx}]}
  case "${token}" in
    \')   __reader_idx=$(( __reader_idx + 1 ))
          _symbol quote; local q="${r}"
          READ_FORM; local f="${r}"
          _list "${q}" "${f}" ;;
    \`)   __reader_idx=$(( __reader_idx + 1 ))
          _symbol quasiquote; local q="${r}"
          READ_FORM; local f="${r}"
          _list "${q}" "${f}" ;;
...
            </code></pre>
            <aside class="notes">
              <ul>
                <li>But then I decided to implement mal in bash. Mal
                and bash have a fairly different architecture.
              </ul>
            </aside>
          </section>
          <section>
            <h2>C</h2>
            <pre><code class="c" data-trim contenteditable>
...
MalVal *read_form(Reader *reader) {
    char *token;
    MalVal *form = NULL, *tmp;
    token = reader_peek(reader);
    if (!token) { return NULL; }
    switch (token[0]) {
    case ';':
        abort("comments not yet implemented");
        break;
    case '\'':
        reader_next(reader);
        form = _listX(2, malval_new_symbol("quote"),
                         read_form(reader));
        break;
...
            </code></pre>
            <aside class="notes">
              <ul>
                <li>Then I did C.
              </ul>
            </aside>
          </section>
          <section>
            <h2>Python</h2>
            <pre><code class="python" data-trim contenteditable>
...
def read_form(reader):
    token = reader.peek()
    # reader macros/transforms
    if token[0] == ';':
        reader.next()
        return None
    elif token == '\'':
        reader.next()
        return _list(_symbol('quote'), read_form(reader))
    elif token == '`':
        reader.next()
        return _list(_symbol('quasiquote'), read_form(reader))
...
            </code></pre>
            <aside class="notes">
              <ul>
                <li>Then python
              </ul>
            </aside>
          </section>
          <section>
            <h2>Clojure</h2>
            <pre><code class="clojure" data-trim contenteditable>
...
;; Override some tools.reader reader macros so that we can do our own
;; metadata and quasiquote handling
(alter-var-root #'r/macros
  (fn [f]
    (fn [ch]
      (case ch
        \` (wrap 'quasiquote)
        \~ (fn [rdr comma]
             (if-let [ch (rt/peek-char rdr)]
               (if (identical? \@ ch)
                 ((wrap 'splice-unquote) (doto rdr rt/read-char) \@)
                 ((wrap 'unquote) rdr \~))))
...
            </code></pre>
            <aside class="notes">
              <ul>
                <li>Clojure
              </ul>
            </aside>
          </section>

          <section>
            <h2>PHP</h2>
            <pre><code class="php" data-trim contenteditable>
...
function read_form($reader) {
    $token = $reader->peek();
    switch ($token) {
    case '\'': $reader->next();
               return _list(_symbol('quote'),
                               read_form($reader));
    case '`':  $reader->next();
               return _list(_symbol('quasiquote'),
                               read_form($reader));
    case '~':  $reader->next();
               return _list(_symbol('unquote'),
                               read_form($reader));
...
            </code></pre>
          </section>

          <section>
            <h2>Java</h2>
            <pre><code class="java" data-trim contenteditable>
...
    public static MalVal read_form(Reader rdr)
            throws MalContinue, ParseError {
        String token = rdr.peek();
        if (token == null) { throw new MalContinue(); }
        MalVal form;

        switch (token.charAt(0)) {
            case '\'': rdr.next();
                       return new MalList(new MalSymbol("quote"),
                                          read_form(rdr));
            case '`': rdr.next();
                      return new MalList(new MalSymbol("quasiquote"),
                                         read_form(rdr));
...
            </code></pre>
          </section>
        </section>

        <section>
          <h2>An Accidental Discovery</h2>
          <p class="fragment">"<font color="green">Ma</font>ke <font color="green">L</font>isp" became "<font color="green">M</font>ake-<font color="green">A</font>-<font color="green">L</font>isp"
          <aside class="notes">
            <ul>
              <li>At some point I began to realize that Mal had become
              a very useful personal learning tool. I was able to
              learn new languages more quickly and to a greater depth
              than any other process I had used before.
              <li><span class="next">&gt;&gt;</span> And so Make Lisp
              became Make-A-Lisp
            </ul>
          </aside>
        </section>

        <section>
          <section>
            <h2>Mal and More Mal</h2>
          </section>
          <section>
            <h2>PostScript</h2>
            <pre><code class="prolog" data-trim contenteditable>
...
% read_form: read the next form from string start at idx
/read_form { 3 dict begin
    read_spaces
    /idx exch def
    /str exch def

    idx str length ge { null str idx }{ %if EOF

    /ch str idx get def  % current character
    ch 39 eq { %if '\''
        /idx idx 1 add def
        str idx read_form
        3 -1 roll   /quote exch 2 _list   3 1 roll
...
            </code></pre>
          <aside class="notes">
            <p>And I kept going</p>
            <p>Yes, Postscript the typesetting language.</p>
          </aside>
          </section>

          <section>
            <h2>C#</h2>
            <pre><code class="csharp" data-trim contenteditable>
...
        public static MalVal read_form(Reader rdr) {
            string token = rdr.peek();
            if (token == null) { throw new MalContinue(); }
            MalVal form = null;

            switch (token) {
                case "'": rdr.next();
                    return new MalList(new MalSymbol("quote"),
                                       read_form(rdr));
                case "`": rdr.next();
                    return new MalList(new MalSymbol("quasiquote"),
                                       read_form(rdr));
...
            </code></pre>
          </section>

          <section>
            <h2>Ruby</h2>
            <pre><code class="ruby" data-trim contenteditable>
...
def read_form(rdr)
    return case rdr.peek
        when ";" then  nil
        when "'" then  rdr.next; List.new [:quote, read_form(rdr)]
        when "`" then  rdr.next; List.new [:quasiquote, read_form(rdr)]
        when "~" then  rdr.next; List.new [:unquote, read_form(rdr)]
        when "~@" then rdr.next; List.new [:"splice-unquote", read_form(rdr)]
        when "^" then  rdr.next; meta = read_form(rdr);
                       List.new [:"with-meta", read_form(rdr), meta]
...
            </code></pre>
          </section>

          <section>
            <h2>Perl</h2>
            <pre><code class="perl" data-trim contenteditable>
...
sub read_form {
    my($rdr) = @_;
    my $token = $rdr->peek();
    given ($token) {
        when("'") { $rdr->next(); List->new([Symbol->new('quote'),
                                             read_form($rdr)]) }
        when('`') { $rdr->next(); List->new([Symbol->new('quasiquote'),
                                             read_form($rdr)]) }
        when('~') { $rdr->next(); List->new([Symbol->new('unquote'),
                                             read_form($rdr)]) }
...
            </code></pre>
          </section>

          <section>
            <h2>Go</h2>
            <pre><code class="golang" data-trim contenteditable>
...
func read_form(rdr Reader) (MalType, error) {
        token := rdr.peek()
        if token == nil {
                return nil, errors.New("read_form underflow")
        }
        switch *token {
        case `'`:
                rdr.next()
                form, e := read_form(rdr)
                if e != nil {
                        return nil, e
                }
                return List{[]MalType{Symbol{"quote"}, form}, nil}, nil
...
            </code></pre>
          </section>

          <section>
            <h2>Rust</h2>
            <pre><code class="rust" data-trim contenteditable>
...
fn read_form(rdr : &mut Reader) -> MalRet {
    let otoken = rdr.peek();
    let stoken = otoken.unwrap();
    let token = &stoken[..];
    match token {
        "'" => {
            let _ = rdr.next();
            match read_form(rdr) {
                Ok(f) => Ok(list(vec![symbol("quote"), f])),
                Err(e) => Err(e),
            }
        },
...
            </code></pre>
            <aside class="notes">
              <p>More challenging then average, but it's a very
              interesting language</p>
            </aside>
          </section>

          <section>
            <h2>R</h2>
            <pre><code class="r" data-trim contenteditable>
...
read_form &lt;- function(rdr) {
    token &lt;- Reader.peek(rdr)
    if (token == "'") {
        . &lt;- Reader.next(rdr);
        new.list(new.symbol("quote"), read_form(rdr))
    } else if (token == "`") {
        . &lt;- Reader.next(rdr);
        new.list(new.symbol("quasiquote"), read_form(rdr))
    } else if (token == "~") {
        . &lt;- Reader.next(rdr);
        new.list(new.symbol("unquote"), read_form(rdr))
...
            </code></pre>
          </section>

          <section>
            <h2>CoffeeScript</h2>
            <pre><code class="coffeescript" data-trim contenteditable>
...
read_form = (rdr) ->
  token = rdr.peek()
  switch token
    when '\'' then [_symbol('quote'), read_form(rdr.skip())]
    when '`'  then [_symbol('quasiquote'), read_form(rdr.skip())]
    when '~'  then [_symbol('unquote'), read_form(rdr.skip())]
    when '~@' then [_symbol('splice-unquote'), read_form(rdr.skip())]
    when '^'
      meta = read_form(rdr.skip())
      [_symbol('with-meta'), read_form(rdr), meta]
    when '@' then [_symbol('deref'), read_form(rdr.skip())]
...
            </code></pre>
          </section>

          <section>
            <h2>VB.NET</h2>
            <pre><code class="vbnet" data-trim contenteditable>
...
        Shared Function read_form(rdr As Reader) As MalVal
            Dim token As String = rdr.peek()
            If token Is Nothing Then
                throw New MalContinue()
            End If
            Dim form As MalVal = Nothing

            Select token
            Case "'"
                rdr.get_next()
                return New MalList(New MalSymbol("quote"),
                                   read_form(rdr))
...
            </code></pre>
          </section>

          <section>
            <h2>Scala</h2>
            <pre><code class="scala" data-trim contenteditable>
...
  def read_form(rdr: Reader): Any = {
    return rdr.peek() match {
      case "'"  => { rdr.next; _list(Symbol("quote"), read_form(rdr)) }
      case "`"  => { rdr.next; _list(Symbol("quasiquote"), read_form(rdr)) }
      case "~"  => { rdr.next; _list(Symbol("unquote"), read_form(rdr)) }
      case "~@" => { rdr.next; _list(Symbol("splice-unquote"), read_form(rdr)) }
      case "^"  => { rdr.next; val meta = read_form(rdr);
                     _list(Symbol("with-meta"), read_form(rdr), meta) }
      case "@"  => { rdr.next; _list(Symbol("deref"), read_form(rdr)) }
...
            </code></pre>
          </section>

          <section>
            <h2>Haskell</h2>
            <pre><code class="haskell" data-trim contenteditable>
...
read_form :: Parser MalVal
read_form =  do
    ignored
    x &lt;- read_macro
     &lt;|> read_list
     &lt;|> read_vector
     &lt;|> read_hash_map
     &lt;|> read_atom
    return $ x

read_str :: String -> IOThrows MalVal
read_str str = case parse read_form "Mal" str of
...
            </code></pre>
          </section>

          <section>
            <h2>Racket</h2>
            <pre><code class="scheme" data-trim contenteditable>
...
(define (read_form rdr)
  (let ([token (send rdr peek)])
    (if (null? token)
      (raise (make-blank-exn "blank line" (current-continuation-marks)))
      (cond
        [(equal? "'" token) (send rdr next) (list 'quote (read_form rdr))]
        [(equal? "`" token) (send rdr next) (list 'quasiquote (read_form rdr))]
        [(equal? "~" token) (send rdr next) (list 'unquote (read_form rdr))]
        [(equal? "~@" token) (send rdr next) (list 'splice-unquote (read_form rdr))]
        [(equal? "^" token) (send rdr next)
                            (let ([meta (read_form rdr)])
                              (list 'with-meta (read_form rdr) meta))]
...
            </code></pre>
          </section>

          <section>
            <h2>Lua</h2>
            <pre><code class="lua" data-trim contenteditable>
...
function M.read_form(rdr)
    local token = rdr:peek()

    if "'" == token then
        rdr:next()
        return List:new({Symbol:new('quote'), M.read_form(rdr)})
    elseif '`' == token then
        rdr:next()
        return List:new({Symbol:new('quasiquote'), M.read_form(rdr)})
    elseif '~' == token then
        rdr:next()
        return List:new({Symbol:new('unquote'), M.read_form(rdr)})
...
            </code></pre>
          </section>

          <section>
            <h2><font color="green">OCaml</font></h2>
            <pre><code class="ocaml" data-trim contenteditable>
...
and read_form all_tokens =
  match all_tokens with
    | [] -> raise End_of_file;
    | token :: tokens ->
      match token with
        | "'"  -> read_quote "quote" tokens
        | "`"  -> read_quote "quasiquote" tokens
        | "~"  -> read_quote "unquote" tokens
        | "~@" -> read_quote "splice-unquote" tokens
        | "@"  -> read_quote "deref" tokens
...
            </code></pre>
            <aside class="notes">
              <ul>
                <li>OCaml was implementation #23
                <li>But there was a critical difference about the
                OCaml implementation: it was created by someone else.
                chouser (a friend and colleague who also wrote the
                book "The Joy of Clojure")
                <li>Marked a new era for mal (Jan 2015). The beginning
                of a step-by-step guide. Other people have created
                more implementations than I have since then.
                <li>Mal and make-a-lisp was no longer just my pet
                project.
                <li>Should be at <span class="next">20</span> min mark
              </ul>
            </aside>
          </section>
        </section>

        <section data-background="#ffffff">
          <h4>Mal Today</h4>
          <img class="fragment" src="media/language_montage.png"
               width="100%" style="box-shadow: none;"></img>
          <aside class="notes">
            <ul>
              <li>Which bring us to today. <span class="next">&gt;&gt;</span>
              <li>There are now 53 implementations.
              <li>20 of the last 31 were created by others.
              <li>The past 12 months have averaged more than
              1.5 implementations per month.
            </ul>
          </aside>
        </section>

        <section data-background="#ffffff" data-transition="none">
          <h2>Let's Make a Lisp</h2>
          <ul class="fragment">
            <li>Hint, to catch up:<br>
              <pre>git checkout stepX_completed</pre>
            <ul>
              <ul>
                <li>where X is current step - 1
              </ul>
            </ul>
          </ul>
          <aside class="notes">
            <ul>
              <li>Enough talking, let's make a lisp
              <li><span class="next">&gt;&gt;</span>The tutorial
              repository is tagged with the incremental steps. To
              catch up, checkout stepX_completed (X = current-1). You
              will need to move your in progress code out of the way
              first (add and stash).
            </ul>
          </aside>
        </section>

        <section data-background="#ffffff" data-transition="none">
          <h3>The Steps</h3>
          <aside class="notes">
            <ul>
              <li>Everybody ready?
            </ul>
          </aside>
        </section>

        <section data-background="#ffffff" data-transition="none">
          <section data-background="#ffffff" data-transition="none">
            <h4>Step 0 - Read/Eval/Print Loop</h4>
            <img src="media/step0_repl.png"
                 width="80%" style="box-shadow: none;"></img>
            <aside class="notes">
              aside/step0.html part 1
            </aside>
          </section>

          <section data-background="#ffffff" data-transition="none">
            <h2>Choose One:</h2>
            <table>
            <tr><td width=20%><font color="green">Ruby</font><br>
                                                  step0_repl.rb</td>
            <td><pre><code class="ruby" data-trim contenteditable>
require "readline"
while line = Readline.readline("user> ", true)
    puts line
end
            </code></pre></td>

            <tr><td width=20%><font color="green">JavaScript</font><br>
                                                  step0_repl.js</td>
            <td><pre><code class="javascript" data-trim contenteditable>
var rlSync = require('./readline').readlineSync
while ((line = rlSync('user> ')) !== null) {
    console.log(line)
}
            </code></pre></td>

            <tr><td width=20%><font color="green">Python 3</font><br>
                                                step0_repl.py</td>
            <td><pre><code class="python" data-trim contenteditable>
import readline
while True:
    try: print(input("user> "))
    except EOFError: break
            </code></pre></td>

            </table>
            <aside class="notes">
              aside/step0.html part 2
            </aside>
          </section>

          <section data-background="#ffffff" data-transition="none">
            <h2>Step 0 Hands On</h2>
            <ul>
              <li>Verify you can run Step 0 in your target language:<br>
                  <pre><code class=bash>ruby ruby/step0_repl.rb</code></pre>
                  <pre><code class=bash>node js/step0_repl.js</code></pre>
                  <pre><code class=bash>python3 python/step0_repl.py</code></pre>
              <li>Get Step 0 tests to run in your target language:<br>
                  <pre><code class=bash>make OPTIONAL=0 test^ruby^step0</code></pre>
                  <pre><code class=bash>make OPTIONAL=0 test^js^step0</code></pre>
                  <pre><code class=bash>make OPTIONAL=0 test^python^step0</code></pre>
            </ul>
          </section>

        </section>

        <section data-background="#ffffff" data-transition="none">
          <section data-background="#ffffff" data-transition="none">
            <h4>Step 1 - Reader & Printer</h4>
            <img src="media/step1_read_print.png"
                 width="80%" style="box-shadow: none;"></img>
            <aside class="notes">
                aside/step1.html part 1
            </aside>
          </section>

          <section data-background="#ffffff" data-transition="none">
            <h3>The Reader</h3>
            <img src="media/reader.png"
                 width="80%" style="box-shadow: none;"></img>
            <aside class="notes">
                aside/step1.html part 2
            </aside>
          </section>

          <section data-background="#ffffff" data-transition="none">
            <h2>Step 1 Hands On</h2>
            <ul>
              <li>Finish implementing read_list() in reader.EXT
              <li>Get step 1 tests to pass:<br>
                  <pre>make OPTIONAL=0 test^<font color="green">IMPL</font>^step1</pre>
            </ul>
            <aside class="notes">
                aside/step1.html part 3
            </aside>
          </section>

        </section>

        <section data-background="#ffffff" data-transition="none">
          <h4>Step 2 - Expression Evaluation</h4>
          <img src="media/step2_eval.png"
               width="80%" style="box-shadow: none;"></img>
          <aside class="notes">
            <ul>
              <li>Simple Calculator
              <li>Lorem ipsum. <span class="next">&gt;&gt;</span>
            </ul>
          </aside>
        </section>

        <section data-background="#ffffff" data-transition="none">
          <h4>Step 3 - Lexical Environments</h4>
          <img src="media/step3_env.png"
               width="80%" style="box-shadow: none;"></img>
          <aside class="notes">
            <ul>
              <li>Calculator with Memory
              <li>Lorem ipsum. <span class="next">&gt;&gt;</span>
            </ul>
          </aside>
        </section>

        <section data-background="#ffffff" data-transition="none">
          <h4>Step 4 - Conditionals, Closures & Side-Effects</h4>
          <img src="media/step4_if_fn_do.png"
               width="80%" style="box-shadow: none;"></img>
          <aside class="notes">
            <ul>
              <li>Barely Lisp
              <li>Lorem ipsum. <span class="next">&gt;&gt;</span>
            </ul>
          </aside>
        </section>

        <section data-background="#ffffff" data-transition="none">
          <h4>Step 5 - Tail-Call Optimization</h4>
          <img src="media/step5_tco.png"
               width="80%" style="box-shadow: none;"></img>
          <aside class="notes">
            <ul>
              <li>More Efficient Lisp
              <li>Lorem ipsum. <span class="next">&gt;&gt;</span>
            </ul>
          </aside>
        </section>

        <section data-background="#ffffff" data-transition="none">
          <h4>Step 6 - Files, Atoms, Arguments & Eval</h4>
          <img src="media/step6_file.png"
               width="80%" style="box-shadow: none;"></img>
          <aside class="notes">
            <ul>
              <li>Meta-circular Evaluator
              <li>Lorem ipsum. <span class="next">&gt;&gt;</span>
            </ul>
          </aside>
        </section>

        <section data-background="#ffffff" data-transition="none">
          <h4>Step 7 - Quote & Quasiquote</h4>
          <img src="media/step7_quote.png"
               width="80%" style="box-shadow: none;"></img>
          <aside class="notes">
            <ul>
              <li>A Touch of Meta-Programming
              <li>Lorem ipsum. <span class="next">&gt;&gt;</span>
            </ul>
          </aside>
        </section>

        <section data-background="#ffffff" data-transition="none">
          <h4>Step 8 - Macros</h4>
          <img src="media/step8_macros.png"
               width="80%" style="box-shadow: none;"></img>
          <aside class="notes">
            <ul>
              <li>Meta-Programming Realized
              <li>Lorem ipsum. <span class="next">&gt;&gt;</span>
            </ul>
          </aside>
        </section>

        <section data-background="#ffffff" data-transition="none">
          <h4>Step 9 - Exception Handling</h4>
          <img src="media/step9_try.png"
               width="80%" style="box-shadow: none;"></img>
          <aside class="notes">
            <ul>
              <li>Try and Try Again
              <li>Lorem ipsum. <span class="next">&gt;&gt;</span>
            </ul>
          </aside>
        </section>

        <section data-background="#ffffff" data-transition="none">
          <h4>Step A - Mal</h4>
          <img src="media/stepA_mal.png"
               width="80%" style="box-shadow: none;"></img>
          <aside class="notes">
            <ul>
              <li>Mal in Mal
              <li>Lorem ipsum. <span class="next">&gt;&gt;</span>
            </ul>
          </aside>
        </section>


        <section>
          <h2>Questions?</h2>
          <div class="fragment">
          <hr>
          <ul>
            <li><a href="https://github.com/kanaka/mal">https://github.com/kanaka/mal</a>
            <li><a href="https://github.com/kanaka/lambdaconf">https://github.com/kanaka/lambdaconf</a>
            <li><span style="color: green">#mal</span> (freenode)
            <li><a href="http://twitter.com/bus_kanaka">@bus_kanaka</a>
            <li><a href="viasat.com">viasat.com</a>
          </ul>
          </div>
          <aside class="notes">
            <ul>
              <li><span class="next">&gt;&gt;</span> I'll also put up
              some reference links while I take questions.
            </ul>
          </aside>
        </section>

        <section>
          <h2>Extra Material</h2>
        </section>

        <section data-background="#ffffff">
          <img src="media/language_graph.png"
               width="70%" style="box-shadow: none;"></img>
        </section>

        <section>
          <h2>New Implementation Ideas</h2>
          <font size=5em>
          <span style="padding: 50px">
          <ul>
            <li>Something old
            <ul>
              <li>Fortran
              <li>COBOL
              <li>Assembly
            </ul>
          </ul>
          </span>
          <span style="padding: 50px">
          <ul>
            <li>Something new
            <ul>
              <li>Idris
              <li>Elm
              <li>TypeScript
            </ul>
          </ul>
          </span>

          <br><br>

          <span style="padding: 50px">
          <ul>
            <li>Something borrowed<br>(from another domain)
            <ul>
              <li>TeX
              <li>Prolog
              <li>nginScript
            </ul>
          </ul>
          </span>
          <span style="padding: 50px">
          <ul>
            <li>Something blue<br>(corporate/government)
            <ul>
              <li>PowerShell
              <li>ColdFusion
              <li>MUMPS (OpenM)
            </ul>
          </ul>
          </font>
          </span>
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });

    </script>

  </body>
</html>
