<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Make Your Own Lisp Interpreter in 10 Incremental Steps</title>

    <meta name="description" content="Make Your Own Lisp Interpreter in 10 Incremental Steps">
    <meta name="author" content="Joel Martin">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section>
          <h1>Make-A-Lisp</h1>
          <h3>Make Your Own Lisp Interpreter in 10 Incremental Steps</h3>
          <p>LambdaConf 2016</p>
          <p><i>Press 's' to show speaker notes</i></p>
          <aside class="notes">
            <ul>
              <li>Silence phone
              <li>Have sized window for mal demo open
              <li>Prune foo from Makefile and foo/
              <li>Build impls: bash, python, js, mal
              <li>Setup screen sharing
              <li>Preload <a href="https://github.com/kanaka/mal/blob/master/process/guide.md">guide</a>
              <li>Preload <a href="https://github.com/kanaka/mal/blob/master/process/guide.md#step0">step0 image</a>, <a href="https://github.com/kanaka/mal/blob/master/process/guide.md#step1">step1 image</a>, <a href="https://github.com/kanaka/mal/blob/master/process/guide.md#step2">step2 image</a> in presentation window for quick tabbing.
            </ul>
          </aside>
        </section>

        <section>
          <h2>About Me</h2>
          <p>Joel Martin (kanaka)</a></p>
          <p><a href="https://github.com/kanaka">github.com/kanaka</a></p>
          <p><a href="http://twitter.com/bus_kanaka">@bus_kanaka</a></p>
          <p>Principal Software Engineer at ViaSat, Inc</p>
          <p class="fragment">Clojure</p>
          <p class="fragment">Satellites!</p>
          <aside class="notes">
            <ul>
                <li>My name is Joel Martin
                <li>Principal Software Engineer at ViaSat, Inc
                <li>At ViaSat I get to build systems using <span
                class="next">&gt;&gt;</span> Clojure, work with some
                amazing people, and <span class="next">&gt;&gt;</span>
                work at a company that does broadband Internet from
                space.
                <li>Thanks to LambdaConf organizers for a great
                conference so far!
            </ul>
          </aside>
        </section>

        <section>
          <h2>The Inspiration</h2>
          <ul>
              <li class="fragment" data-fragment-index="1">Gherkin<br>
              <li class="fragment" data-fragment-index="3">lispy</li>
              <span class="fragment fade-in" data-fragment-index="2">
                <span class="fragment fade-out" data-fragment-index="3">
                  <img src="media/mindblown.gif"></img>
                </span>
              </span>
          </ul>
          <aside class="notes">
            <ul>
                <li>I'm going to tell you a personal story about
                language learning.
                <li>
                  <ul>
                    <li> <span class="next">&gt;&gt;</span> Way back in 2013, Alan Dipert presented this at Clojure/conj
                    <li>A Lisp implemented in bash <span class="next">&gt;&gt;</span> [mindblown]
                    <li>This was basically my reaction.
                    <li>Raised the question for me: what other
                    non-traditional language could a Lisp be
                    implemented in?
                    <li>Had particular language in mind. As far as
                    I knew, no one had ever written a Lisp using it.
                    You'll see why in a moment.
                  </ul>
                <li><span class="next">&gt;&gt;</span> Lispy: a small and simple Python implementation of
                a Lisp interpreter by Peter Norvig. I used that as
                a model.
            </ul>
          </aside>
        </section>

        <section>
          <section>
            <h2>Mal Beginnings</h2>
            <aside class="notes">
              A bit on how mal began
              <span class="next">vv</span>
            </aside>
          </section>

          <section>
            <h2>JS</h2>
            <pre><code class="hljs" data-trim contenteditable>
...
function read_form(reader) {
    var token = reader.peek();
    switch (token) {
    // reader macros/transforms
    case ';': return null; // Ignore comments
    case '\'': reader.next();
               return [types._symbol('quote'), read_form(reader)];
    case '`': reader.next();
              return [types._symbol('quasiquote'), read_form(reader)];
    case '~': reader.next();
              return [types._symbol('unquote'), read_form(reader)];
...
            </code></pre>
            <aside class="notes">
              First did an implementation in JS to make sure
              I understood the process well. I had not made a Lisp
              from scratch before.
            </aside>
          </section>
          <section>
            <h2 class="fragment" data-fragment-index="1">GNU Make</h2>
            <pre><code class="hljs" data-trim contenteditable>
...
define READ_FORM
$(and $(READER_DEBUG),$(info READ_FORM: $($(1))))
$(call READ_SPACES,$(1))
$(foreach ch,$(word 1,$($(1))),\
  $(if $(filter $(SEMI),$(ch)),\
    $(call DROP_UNTIL,$(1),$(_NL)),\
  $(if $(filter $(SQUOTE),$(ch)),\
    $(eval $(1) := $(wordlist 2,$(words $($(1))),$($(1))))\
    $(call _list,$(call _symbol,quote) $(strip $(call READ_FORM,$(1)))),\
  $(if $(filter $(QQUOTE),$(ch)),\
    $(eval $(1) := $(wordlist 2,$(words $($(1))),$($(1))))\
    $(call _list,$(call _symbol,quasiquote) $(strip $(call READ_FORM,$(1)))),\
  $(if $(filter $(UNQUOTE),$(ch)),\
...
            </code></pre>
            <p class="fragment" class="fragment" data-fragment-index="2">"<font color="green">Ma</font>ke <font color="green">L</font>isp"
            <aside class="notes">
              <ul>
                <li>Here is a sample of the code from the target
                language that I was inspired to write a Lisp in.
                Anybody willing to guess what language this example
                code is written in?
                <li><span class="next">&gt;&gt;</span> GNU Make. And
                yes, it's really does work and it's a full
                implementation.
                <li><span class="next">SWITCH</span>
                <li>Demo
                <pre style="background: #aaa;">
cd make
make -f ./mal.mk
user&gt; ( (fn* [a b] (* a b)) 7 8)
less mal.mk</pre>
                <li><span class="next">SWITCH</span> <span
                    class="next">&gt;&gt;</span> The name "Mal"
                original "MAke Lisp" because that was all I was really
                originally intenteding to do. But then I had the
                thought...
                <li>Should be at <span class="next">10</span> min mark
              </ul>
          </section>
          <section>
            <h2>Bash</h2>
            <pre><code class="bash" data-trim contenteditable>
...
READ_FORM () {
  local token=${__reader_tokens[${__reader_idx}]}
  case "${token}" in
    \')   __reader_idx=$(( __reader_idx + 1 ))
          _symbol quote; local q="${r}"
          READ_FORM; local f="${r}"
          _list "${q}" "${f}" ;;
    \`)   __reader_idx=$(( __reader_idx + 1 ))
          _symbol quasiquote; local q="${r}"
          READ_FORM; local f="${r}"
          _list "${q}" "${f}" ;;
...
            </code></pre>
            <aside class="notes">
              <ul>
                <li>My JS and Make Lisp interpreters had a fairly
                different structure compared to Gherkin. So I decided
                to try my hand at Bash.
                <li>Began to see patterns. Started thinking in terms
                of small digestable chunks, largely due to the fact my
                life, job and school meant I only had short segments
                of time to work on it.
                <li>Often it was at night while working on graduate
                classes when I would take a 5-10 minute break and work
                on whatever current mal implementation I happened to
                have in the pipeline. And I'm not that brilliant so
                I was forced to make a process that was very gradual
                and incremental.
              </ul>
            </aside>
          </section>
          <section>
            <h2>C</h2>
            <pre><code class="c" data-trim contenteditable>
...
MalVal *read_form(Reader *reader) {
    char *token;
    MalVal *form = NULL, *tmp;
    token = reader_peek(reader);
    if (!token) { return NULL; }
    switch (token[0]) {
    case ';':
        abort("comments not yet implemented");
        break;
    case '\'':
        reader_next(reader);
        form = _listX(2, malval_new_symbol("quote"),
                         read_form(reader));
        break;
...
            </code></pre>
            <aside class="notes">
              <ul>
                <li>First statically typed language. Led to
                restructuring of the earlier 3 implementations. More
                patterns became apparent.
              </ul>
            </aside>
          </section>
          <section>
            <h2>Python</h2>
            <pre><code class="python" data-trim contenteditable>
...
def read_form(reader):
    token = reader.peek()
    # reader macros/transforms
    if token[0] == ';':
        reader.next()
        return None
    elif token == '\'':
        reader.next()
        return _list(_symbol('quote'), read_form(reader))
    elif token == '`':
        reader.next()
        return _list(_symbol('quasiquote'), read_form(reader))
...
            </code></pre>
            <aside class="notes">
              <ul>
                <li>Mal had become a fairly different Lisp from Lispy
                by this point. It modelled it on Clojure's syntax and
                immutability because that was the Lisp I knew and
                loved. But since Python was loosely part of the
                heritage I decided I had to do python too.
              </ul>
            </aside>
          </section>
          <section>
            <h2>Clojure</h2>
            <pre><code class="clojure" data-trim contenteditable>
...
;; Override some tools.reader reader macros so that we can do our own
;; metadata and quasiquote handling
(alter-var-root #'r/macros
  (fn [f]
    (fn [ch]
      (case ch
        \` (wrap 'quasiquote)
        \~ (fn [rdr comma]
             (if-let [ch (rt/peek-char rdr)]
               (if (identical? \@ ch)
                 ((wrap 'splice-unquote) (doto rdr rt/read-char) \@)
                 ((wrap 'unquote) rdr \~))))
...
            </code></pre>
            <aside class="notes">
              <ul>
                <li>And of course, since Mal is a Clojure-like Lisp,
                I had to do in implementation in Clojure.
                <li>This was really enlightening in terms of what
                parts of Mal were really Lisp nature, and which parts
                were really just incidental complexity due to
                nature or dificiencies of the target language. And
                I began to strongly structure the code and the
                incremental steps to reflect that.
                <li>However, I should point out that I later realized
                that the "incidental complexity" is actually one of
                the most useful aspects of mal, but we'll get to that.
              </ul>
            </aside>
          </section>

          <section>
            <h2>PHP</h2>
            <pre><code class="php" data-trim contenteditable>
...
function read_form($reader) {
    $token = $reader->peek();
    switch ($token) {
    case '\'': $reader->next();
               return _list(_symbol('quote'),
                               read_form($reader));
    case '`':  $reader->next();
               return _list(_symbol('quasiquote'),
                               read_form($reader));
    case '~':  $reader->next();
               return _list(_symbol('unquote'),
                               read_form($reader));
...
            </code></pre>
          </section>

          <section>
            <h2>Java</h2>
            <pre><code class="java" data-trim contenteditable>
...
    public static MalVal read_form(Reader rdr)
            throws MalContinue, ParseError {
        String token = rdr.peek();
        if (token == null) { throw new MalContinue(); }
        MalVal form;

        switch (token.charAt(0)) {
            case '\'': rdr.next();
                       return new MalList(new MalSymbol("quote"),
                                          read_form(rdr));
            case '`': rdr.next();
                      return new MalList(new MalSymbol("quasiquote"),
                                         read_form(rdr));
...
            </code></pre>
          </section>
        </section>

        <section>
          <h2>An Accidental Discovery</h2>
          <p class="fragment">"<font color="green">Ma</font>ke <font color="green">L</font>isp" became "<font color="green">M</font>ake-<font color="green">A</font>-<font color="green">L</font>isp"
          <aside class="notes">
            <ul>
              <li>At some point I began to realize that Mal had become
              a very useful personal learning tool. I was able to
              learn new languages more quickly and to a greater depth
              than any other process I had used before.
              <li><span class="next">&gt;&gt;</span> And so Make Lisp
              became Make-A-Lisp
              <li>But before we switch gears and focus on the language
              learning aspects of the make-a-lisp process, let's
              take brief look at mal the language along with a couple
              of implementations.
            </ul>
          </aside>
        </section>

        <section>
          <h2>Mal Itself</h2>
          <p>Demo Time</p>
          <img class="fragment" src="media/surprised-baby.gif"></img>
          <aside class="notes">
            <font size="1em">
            <ul>
              <li>Should be at <span class="next">15</span> min mark
              <li><span class="next">SWITCH</span>
              <li>Let's start with a hello world mal program:
<pre style="margin: 0px; background: #aaa;">
cd ../python
cat ../mal/hello.py</pre>
              <li>but let's run it with the python implementation:
<pre style="margin: 0px; background: #aaa;">
./mal.py ../mal/hello.py</pre>
              <li>Let's try something a bit more interesting but this
              time using the bash implementation:
<pre style="margin: 0px; background: #aaa;">
cd ../bash
./mal.sh ../mal/clojurewest2014.mal</pre>
              <li>That's a presentation for a lightning talke I did on
              mal at Clojure West.
<pre style="margin: 0px; background: #aaa;">
less ../mal/clojurewest2014.mal</pre>
              <li>That's all well and good, but let's bump it up
              a notch or three:
<pre style="margin: 0px; background: #aaa;">
cd ../js
./mal.js ../mal/mal.mal</pre>
              <li>I'll just pause for a second to let you stew on
              that.
              <li>Yes, that's the mal implementation of mal

              <li><span class="next">SWITCH</span>[show gif]
              <li>This was basically my reaction at the moment when
              mal became self-hosting.
              <li><span class="next">SWITCH</span>
<pre style="margin: 0px; background: #aaa;">
less ../mal/mal.mal
</pre>
              <li>More specifically, that's the JavaScript
              implementation of mal being used to run an
              implementation of mal that is written in the mal
              language itself
              <li>Self-hosting is the term for an interpreter or
              compiler that is written in it's own language.
<!--
<pre style="margin: 0px; background: #aaa;">
less ../mal/mal.mal</pre>
              <li>And of course we can do this:
<pre style="margin: 0px; background: #aaa;">
./mal.js ../mal/mal.mal ../mal/hello.mal</pre>
              <li>It's much slower, but it works the same
-->
            </ul>
            </font>
          </aside>
        </section>

        <section>
          <section>
            <h2>Mal and More Mal</h2>
          </section>
          <section>
            <h2>PostScript</h2>
            <pre><code class="prolog" data-trim contenteditable>
...
% read_form: read the next form from string start at idx
/read_form { 3 dict begin
    read_spaces
    /idx exch def
    /str exch def

    idx str length ge { null str idx }{ %if EOF

    /ch str idx get def  % current character
    ch 39 eq { %if '\''
        /idx idx 1 add def
        str idx read_form
        3 -1 roll   /quote exch 2 _list   3 1 roll
...
            </code></pre>
          <aside class="notes">
            <p>Yes, Postscript the typesetting language.</p>
            <p>After my lightning talk at Clojure West somebody
            suggested Postscript and so I took up the challenge.</p>
            <p>I had never written a line of code in
            a stack-based/concatenative language like Postscript</p>
            <p>More challenging than most, not as difficult as GNU
            Make</p>
          </aside>
          </section>

          <section>
            <h2>C#</h2>
            <pre><code class="csharp" data-trim contenteditable>
...
        public static MalVal read_form(Reader rdr) {
            string token = rdr.peek();
            if (token == null) { throw new MalContinue(); }
            MalVal form = null;

            switch (token) {
                case "'": rdr.next();
                    return new MalList(new MalSymbol("quote"),
                                       read_form(rdr));
                case "`": rdr.next();
                    return new MalList(new MalSymbol("quasiquote"),
                                       read_form(rdr));
...
            </code></pre>
          </section>

          <section>
            <h2>Ruby</h2>
            <pre><code class="ruby" data-trim contenteditable>
...
def read_form(rdr)
    return case rdr.peek
        when ";" then  nil
        when "'" then  rdr.next; List.new [:quote, read_form(rdr)]
        when "`" then  rdr.next; List.new [:quasiquote, read_form(rdr)]
        when "~" then  rdr.next; List.new [:unquote, read_form(rdr)]
        when "~@" then rdr.next; List.new [:"splice-unquote", read_form(rdr)]
        when "^" then  rdr.next; meta = read_form(rdr);
                       List.new [:"with-meta", read_form(rdr), meta]
...
            </code></pre>
          </section>

          <section>
            <h2>Perl</h2>
            <pre><code class="perl" data-trim contenteditable>
...
sub read_form {
    my($rdr) = @_;
    my $token = $rdr->peek();
    given ($token) {
        when("'") { $rdr->next(); List->new([Symbol->new('quote'),
                                             read_form($rdr)]) }
        when('`') { $rdr->next(); List->new([Symbol->new('quasiquote'),
                                             read_form($rdr)]) }
        when('~') { $rdr->next(); List->new([Symbol->new('unquote'),
                                             read_form($rdr)]) }
...
            </code></pre>
          </section>

          <section>
            <h2>Go</h2>
            <pre><code class="golang" data-trim contenteditable>
...
func read_form(rdr Reader) (MalType, error) {
        token := rdr.peek()
        if token == nil {
                return nil, errors.New("read_form underflow")
        }
        switch *token {
        case `'`:
                rdr.next()
                form, e := read_form(rdr)
                if e != nil {
                        return nil, e
                }
                return List{[]MalType{Symbol{"quote"}, form}, nil}, nil
...
            </code></pre>
          </section>

          <section>
            <h2>Rust</h2>
            <pre><code class="rust" data-trim contenteditable>
...
fn read_form(rdr : &mut Reader) -> MalRet {
    let otoken = rdr.peek();
    let stoken = otoken.unwrap();
    let token = &stoken[..];
    match token {
        "'" => {
            let _ = rdr.next();
            match read_form(rdr) {
                Ok(f) => Ok(list(vec![symbol("quote"), f])),
                Err(e) => Err(e),
            }
        },
...
            </code></pre>
            <aside class="notes">
              <p>More challenging then average, but it's a very
              interesting language</p>
            </aside>
          </section>

          <section>
            <h2>R</h2>
            <pre><code class="r" data-trim contenteditable>
...
read_form &lt;- function(rdr) {
    token &lt;- Reader.peek(rdr)
    if (token == "'") {
        . &lt;- Reader.next(rdr);
        new.list(new.symbol("quote"), read_form(rdr))
    } else if (token == "`") {
        . &lt;- Reader.next(rdr);
        new.list(new.symbol("quasiquote"), read_form(rdr))
    } else if (token == "~") {
        . &lt;- Reader.next(rdr);
        new.list(new.symbol("unquote"), read_form(rdr))
...
            </code></pre>
          </section>

          <section>
            <h2>CoffeeScript</h2>
            <pre><code class="coffeescript" data-trim contenteditable>
...
read_form = (rdr) ->
  token = rdr.peek()
  switch token
    when '\'' then [_symbol('quote'), read_form(rdr.skip())]
    when '`'  then [_symbol('quasiquote'), read_form(rdr.skip())]
    when '~'  then [_symbol('unquote'), read_form(rdr.skip())]
    when '~@' then [_symbol('splice-unquote'), read_form(rdr.skip())]
    when '^'
      meta = read_form(rdr.skip())
      [_symbol('with-meta'), read_form(rdr), meta]
    when '@' then [_symbol('deref'), read_form(rdr.skip())]
...
            </code></pre>
          </section>

          <section>
            <h2>VB.NET</h2>
            <pre><code class="vbnet" data-trim contenteditable>
...
        Shared Function read_form(rdr As Reader) As MalVal
            Dim token As String = rdr.peek()
            If token Is Nothing Then
                throw New MalContinue()
            End If
            Dim form As MalVal = Nothing

            Select token
            Case "'"
                rdr.get_next()
                return New MalList(New MalSymbol("quote"),
                                   read_form(rdr))
...
            </code></pre>
          </section>

          <section>
            <h2>Scala</h2>
            <pre><code class="scala" data-trim contenteditable>
...
  def read_form(rdr: Reader): Any = {
    return rdr.peek() match {
      case "'"  => { rdr.next; _list(Symbol("quote"), read_form(rdr)) }
      case "`"  => { rdr.next; _list(Symbol("quasiquote"), read_form(rdr)) }
      case "~"  => { rdr.next; _list(Symbol("unquote"), read_form(rdr)) }
      case "~@" => { rdr.next; _list(Symbol("splice-unquote"), read_form(rdr)) }
      case "^"  => { rdr.next; val meta = read_form(rdr);
                     _list(Symbol("with-meta"), read_form(rdr), meta) }
      case "@"  => { rdr.next; _list(Symbol("deref"), read_form(rdr)) }
...
            </code></pre>
          </section>

          <section>
            <h2>Haskell</h2>
            <pre><code class="haskell" data-trim contenteditable>
...
read_form :: Parser MalVal
read_form =  do
    ignored
    x &lt;- read_macro
     &lt;|> read_list
     &lt;|> read_vector
     &lt;|> read_hash_map
     &lt;|> read_atom
    return $ x

read_str :: String -> IOThrows MalVal
read_str str = case parse read_form "Mal" str of
...
            </code></pre>
          </section>

          <section>
            <h2>Racket</h2>
            <pre><code class="scheme" data-trim contenteditable>
...
(define (read_form rdr)
  (let ([token (send rdr peek)])
    (if (null? token)
      (raise (make-blank-exn "blank line" (current-continuation-marks)))
      (cond
        [(equal? "'" token) (send rdr next) (list 'quote (read_form rdr))]
        [(equal? "`" token) (send rdr next) (list 'quasiquote (read_form rdr))]
        [(equal? "~" token) (send rdr next) (list 'unquote (read_form rdr))]
        [(equal? "~@" token) (send rdr next) (list 'splice-unquote (read_form rdr))]
        [(equal? "^" token) (send rdr next)
                            (let ([meta (read_form rdr)])
                              (list 'with-meta (read_form rdr) meta))]
...
            </code></pre>
          </section>

          <section>
            <h2>Lua</h2>
            <pre><code class="lua" data-trim contenteditable>
...
function M.read_form(rdr)
    local token = rdr:peek()

    if "'" == token then
        rdr:next()
        return List:new({Symbol:new('quote'), M.read_form(rdr)})
    elseif '`' == token then
        rdr:next()
        return List:new({Symbol:new('quasiquote'), M.read_form(rdr)})
    elseif '~' == token then
        rdr:next()
        return List:new({Symbol:new('unquote'), M.read_form(rdr)})
...
            </code></pre>
          </section>

          <section>
            <h2><font color="green">OCaml</font></h2>
            <pre><code class="ocaml" data-trim contenteditable>
...
and read_form all_tokens =
  match all_tokens with
    | [] -> raise End_of_file;
    | token :: tokens ->
      match token with
        | "'"  -> read_quote "quote" tokens
        | "`"  -> read_quote "quasiquote" tokens
        | "~"  -> read_quote "unquote" tokens
        | "~@" -> read_quote "splice-unquote" tokens
        | "@"  -> read_quote "deref" tokens
...
            </code></pre>
            <aside class="notes">
              <ul>
                <li>OCaml was implementation #23
                <li>But there was a critical difference about the
                OCaml implementation: it was created by someone else.
                chouser (a friend and colleague who also wrote the
                book "The Joy of Clojure")
                <li>Marked a new era for mal (Jan 2015). The beginning
                of a step-by-step guide. Other people have created
                more implementations that I have since then.
                <li>Mal and make-a-lisp was no longer just my pet
                project.
                <li>Should be at <span class="next">20</span> min mark
              </ul>
            </aside>
          </section>
        </section>

        <section data-background="#ffffff">
          <h3>Mal Today</h3>
          <img class="fragment" src="media/language_montage.png"
               width="80%" style="box-shadow: none;"></img>
          <aside class="notes">
            <ul>
              <li>Which bring us to today. <span class="next">&gt;&gt;</span>
              <li>There are now 42 implementations.
              <li>14 of the last 20 were created by others. And of the
              six I created many were either variations of exisiting
              implementations (like ES6 and rpython) or to learn
              a language for one of my PhD classes (like MATLAB) [or
              experiment with a language idea for work (miniMAL)].
              <li>The past 12 months have averaged more than
              2 implementations per month.
              <li>At this point you might be asking yourself "Why"?
              Why did a bunch of people go through the work to do
              this?
              <li>The answer is actually really simple: because it was
              fun! And not just fun, but addictive fun.
            </ul>
          </aside>
        </section>

        <section data-background="#ffffff" data-transition="none">
          <h3>The Steps</h3>
          <aside class="notes">
            <ul>
              <li>Lorem ipsum. <span class="next">&gt;&gt;</span>
            </ul>
          </aside>
        </section>

        <section data-background="#ffffff" data-transition="none">
          <h4>Step 0 - Read/Eval/Print Loop</h4>
          <img src="media/step0_repl.png"
               width="80%" style="box-shadow: none;"></img>
          <aside class="notes">
            <ul>
             <li>Input and Output
              <li>Lorem ipsum. <span class="next">&gt;&gt;</span>
            </ul>
          </aside>
        </section>

        <section data-background="#ffffff" data-transition="none">
          <h4>Step 1 - Reader & Printer</h4>
          <img src="media/step1_read_print.png"
               width="80%" style="box-shadow: none;"></img>
          <aside class="notes">
            <ul>
              <li>Syntax Checker
              <li>Lorem ipsum. <span class="next">&gt;&gt;</span>
            </ul>
          </aside>
        </section>

        <section data-background="#ffffff" data-transition="none">
          <h4>Step 2 - Expression Evaluation</h4>
          <img src="media/step2_eval.png"
               width="80%" style="box-shadow: none;"></img>
          <aside class="notes">
            <ul>
              <li>Simple Calculator
              <li>Lorem ipsum. <span class="next">&gt;&gt;</span>
            </ul>
          </aside>
        </section>

        <section data-background="#ffffff" data-transition="none">
          <h4>Step 3 - Lexical Environments</h4>
          <img src="media/step3_env.png"
               width="80%" style="box-shadow: none;"></img>
          <aside class="notes">
            <ul>
              <li>Calculator with Memory
              <li>Lorem ipsum. <span class="next">&gt;&gt;</span>
            </ul>
          </aside>
        </section>

        <section data-background="#ffffff" data-transition="none">
          <h4>Step 4 - Conditionals, Closures & Side-Effects</h4>
          <img src="media/step4_if_fn_do.png"
               width="80%" style="box-shadow: none;"></img>
          <aside class="notes">
            <ul>
              <li>Barely Lisp
              <li>Lorem ipsum. <span class="next">&gt;&gt;</span>
            </ul>
          </aside>
        </section>

        <section data-background="#ffffff" data-transition="none">
          <h4>Step 5 - Tail-Call Optimization</h4>
          <img src="media/step5_tco.png"
               width="80%" style="box-shadow: none;"></img>
          <aside class="notes">
            <ul>
              <li>More Efficient Lisp
              <li>Lorem ipsum. <span class="next">&gt;&gt;</span>
            </ul>
          </aside>
        </section>

        <section data-background="#ffffff" data-transition="none">
          <h4>Step 6 - Files, Atoms, Arguments & Eval</h4>
          <img src="media/step6_file.png"
               width="80%" style="box-shadow: none;"></img>
          <aside class="notes">
            <ul>
              <li>Meta-circular Evaluator
              <li>Lorem ipsum. <span class="next">&gt;&gt;</span>
            </ul>
          </aside>
        </section>

        <section data-background="#ffffff" data-transition="none">
          <h4>Step 7 - Quote & Quasiquote</h4>
          <img src="media/step7_quote.png"
               width="80%" style="box-shadow: none;"></img>
          <aside class="notes">
            <ul>
              <li>A Touch of Meta-Programming
              <li>Lorem ipsum. <span class="next">&gt;&gt;</span>
            </ul>
          </aside>
        </section>

        <section data-background="#ffffff" data-transition="none">
          <h4>Step 8 - Macros</h4>
          <img src="media/step8_macros.png"
               width="80%" style="box-shadow: none;"></img>
          <aside class="notes">
            <ul>
              <li>Meta-Programming Realized
              <li>Lorem ipsum. <span class="next">&gt;&gt;</span>
            </ul>
          </aside>
        </section>

        <section data-background="#ffffff" data-transition="none">
          <h4>Step 9 - Exception Handling</h4>
          <img src="media/step9_try.png"
               width="80%" style="box-shadow: none;"></img>
          <aside class="notes">
            <ul>
              <li>Try and Try Again
              <li>Lorem ipsum. <span class="next">&gt;&gt;</span>
            </ul>
          </aside>
        </section>

        <section data-background="#ffffff" data-transition="none">
          <h4>Step A - Mal</h4>
          <img src="media/stepA_mal.png"
               width="80%" style="box-shadow: none;"></img>
          <aside class="notes">
            <ul>
              <li>Mal in Mal
              <li>Lorem ipsum. <span class="next">&gt;&gt;</span>
            </ul>
          </aside>
        </section>


        <section>
          <h2>Questions?</h2>
          <div class="fragment">
          <hr>
          <ul>
            <li><a href="https://github.com/kanaka/mal">https://github.com/kanaka/mal</a>
            <li><a href="https://github.com/kanaka/lambdaconf">https://github.com/kanaka/lambdaconf</a>
            <li><span style="color: green">#mal</span> (freenode)
            <li><a href="http://twitter.com/bus_kanaka">@bus_kanaka</a>
            <li><a href="viasat.com">viasat.com</a>
          </ul>
          </div>
          <aside class="notes">
            <ul>
              <li><span class="next">&gt;&gt;</span> I'll also put up
              some reference links while I take questions.
            </ul>
          </aside>
        </section>

        <section>
          <h2>Extra Material</h2>
        </section>

        <section data-background="#ffffff">
          <img src="media/language_graph.png"
               width="70%" style="box-shadow: none;"></img>
        </section>

        <section>
          <h2>New Implementation Ideas</h2>
          <font size=5em>
          <span style="padding: 50px">
          <ul>
            <li>Something old
            <ul>
              <li>Fortran
              <li>COBOL
              <li>Pascal
              <li>Ada
              <li>Assembly
            </ul>
          </ul>
          </span>
          <span style="padding: 50px">
          <ul>
            <li>Something new
            <ul>
              <li>Idris
              <li>Io
              <li>Dart
              <li>Elm
              <li>TypeScript
            </ul>
          </ul>
          </span>

          <br><br>

          <span style="padding: 50px">
          <ul>
            <li>Something borrowed<br>(from another domain)
            <ul>
              <li>TeX
              <li>PL/SQL
              <li>Prolog
              <li>Verilog / VHDL
            </ul>
          </ul>
          </span>
          <span style="padding: 50px">
          <ul>
            <li>Something blue<br>(corporate/government)
            <ul>
              <li>Objective-C
              <li>PowerShell
              <li>ColdFusion
              <li>MUMPS (OpenM)
            </ul>
          </ul>
          </font>
          </span>
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });

    </script>

  </body>
</html>
